* Java
** Java NIO
*** 目的
使用高速 IO 而无需编写自定义的本机代码。
将最耗时间的 IO 操作转移回操作系统。
*** 与传统 IO 的比较
一个是面向块的，一个是面向流的。
+ 传统 IO：简单优雅，但速度慢
*** 核心对象
**** 通道与缓冲区
***** 通道(channel)：对原 IO 包的流的模拟。
***** 缓冲区(buffer)：
 + Position:当前位置
 + Limit:最大可读/写的位置
 + Capacity:
**** 非阻塞 IO
Java NIO 可以让你非阻塞地使用 IO
**** 选择器
+ 单个线程可以监听多个通信信道的事件
+ 注册 IO 事件的地方
*** IO 模型
IO 复用
*** 应用场景
+ 高性能，高容量服务端应用程序
+ 网络协议的解析，TCP 拆包，粘包
+ 远程过程调用 RPC
+ C10K 问题:在有1万个同时连接时，传统的阻塞的，每个连接一个线程的网络处理方式存在的问题
*** IO 多路复用模式
一般来说，IO多路复用机制需要使用事件分发器，来将读写事件源分发给读写事件的处理者。
**** Proactor
+ 基于异步 IO 的。
+ 事件处理者直接发起一个异步读写操作，而实际的工作是由操作系统来完成的。
+ 事件分发器得到这个请求，默默等待这个请求的完成，然后转发完成事件给相应的事件完成者或回调。
+ 你给我收十个字节，收好了你跟俺说一声
***** 操作步骤
1.等待事件到来（Proactor负责）。
2.得到读就绪事件，执行读数据（现在由Proactor负责）。
3.将读完成事件分发给用户处理器（Proactor负责）。
4.处理数据（用户处理器负责）。
**** Reactor
+ 基于同步 IO
+ 事件分发器等待某个事件或者某个可应用或可操作的状态的发生。
+ 转发给事先注册的回调，来做实际的读写操作。
+ 能收了你跟俺说一声
***** 操作步骤
1.等待事件到来（Reactor负责）。
2.将读就绪事件分发给用户定义的处理器（Reactor负责）。
3.读数据（用户处理器负责）。
4.处理数据（用户处理器负责）。

** JVM 垃圾收集
*** 对象死亡了吗
+ 引用计数法
+ 可达性分析
*** 垃圾回收算法 
+ 标记-清除算法
+ 复制算法
+ 标记-整理算法
+ 分代收集算法
*** HotSpot 算法优化
**** 枚举根节点
在可达性分析中，使用 OopMap 记录引用位置及类型。
**** 安全点
只在特定的点生成 OopMap -- 节省空间。
**** 安全区域
将安全点拓展到区域上 -- 防止无法响应 JVM 的中断请求。
*** 垃圾收集器
**** Serial 收集器
单线程，Client模式下的默认新生代收集器，简单高校。
**** ParNew 收集器
多线程，在单 CPU 下效果不好，在多个 CPU 情况下效果好。
**** Parallel Scavenge 收集器
+ 目的：达到一个可控制的吞吐量。
+ GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的。
+ GC 自适应调整策略：通过检测来调整。
**** Serial Old 收集器
**** Parallel Old 收集器
Parallel Scavenge 的老年代版本。
**** CMS 收集器
+ 目的：获取最短回收停顿时间为目标。
+ 优点：并发收集，低停顿。
+ 缺点：
  + 对 CPU 资源敏感
  + 无法处理浮动垃圾
  + 大量空间碎片(标记-清楚）
**** G1 收集器
+ 新生代老年代通吃。
+ 特点：
  + 并行与并发
  + 分代收集
  + 空间整合
  + 可预测的停顿
+ G1 跟踪各个 Region 里面的垃圾收集堆积的价值大小。
+ 在 G1 收集器中使用 Remembered Set 来避免全堆扫描。
+ 在刷选阶段，根据用户所期望的 GC 停顿时间来制定回收计划。
+ 如果你的应用追求低停顿，那就可以选择 G1。

*** 内存分配与回收策略
不管是在新生代还是老年代，其内存不够时，发起Minor GC/Full GC。
**** 新生代
一般分为 Eden 和 Survivor（两个，轮换使用），8：1
**** 老年代
+ 大对象直接进入老年代
+ 长期存活的进入老年代
+ 动态对象年龄
** JVM 数据区域
+ 虚拟机栈
+ 本地方法栈：Native方法服务
+ 方法区：存储已被虚拟机加载的类信息、静态变量、即时编译器编译后的代码等数据。
+ 堆：存放对象实例。
** hashCode 与 equals 方法
*** equals 的作用
+ 用来判断两个对象是否相等
+ 在 JDK 中，通过判断两个对象的地址是否相等来区分它们是否相等
+ 可以依据需要对方法进行覆盖（如果没有覆盖，其作用和 == 相同）
*** hashCode 的作用
+ hashCode 的作用是获取哈希码，也称为散列码；它实际返回一个 int 整数。
*** equals 和 hashCode 之间的关系
**** 不会创建类对应的散列表
+ 不会在 HashSet HashTable HashMap 等本质上是散列表的数据结构中用到该类。 
+ 此时 hashCode 和 equals 无关。
**** 会创建类对应的散列表
+ 如果 equals 判断两个对象相等，则 hashCode 一定相等。
+ 如果两个对象的 hashCode 相等，其 equals 不一定判断相等。
+ 如果覆盖了 equals 方法，也需要覆盖对应的 hashCode 方法，否则散列表中将存在重复值。
* Python
* 计算机系统
** 进程，线程与协程
*** 进程与线程区别
+ 进程是资源分配的基本单位，线程是 CPU 调度/程序执行的最小单位。
+ 进程有独立的地址空间，需要维护页表等和内存缓存打交道的数据结构。
  + 进程共享状态信息比较困难，需要使用显示的 IPC 机制。
  + 线程之间的通信比较方便，使用(全局变量，静态变量等方式)。
+ 线程比进程的操作要快，花费要小。
+ 在 Linux 下本质都是 Task，需要共享的都可以选择，这两个概念上的差别被弱化了。
+ 同步与互斥的方法：临界区，事件，互斥量，信号量。
+ 多线程的好处：并发，更好的编程模型。
** 线程安全
一个函数是线程安全的，当且仅当其被多个并发线程反复的调用时，一直会产生正确的结果。
*** 四类线程不安全函数
+ 不保护共享变量的函数
+ 保持跨越多个调用的状态的函数
+ 返回指向静态变量的指针的函数
+ 调用线程不安全函数的函数
*** 可重入
当他们被多个线程调用时，不会引用任何共享数据。
** 进程间通信
+ 管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道还允许无亲缘关系进程间的通信；
+ 信号（Signal）：用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；
+ 报文（Message）队列（消息队列）：消息队列是消息的链接表。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
+ 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
+ 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
+ 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。
* 计算机网络
** 网络 IO 模型
网络应用需要处理的无非就是两大类问题，网络I/O，数据计算。相对于后者，网络I/O的延迟，给应用带来的性能瓶颈大于后者

网络I/O的本质是socket的读取，socket在linux系统被抽象为流，I/O可以理解为对流的操作。这个操作又分为两个阶段：
+ 等待流数据准备（wating for the data to be ready）。
+ 从内核向进程复制数据（copying the data from the kernel to the process）。

对于socket流而已，
+ 第一步通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。
+ 第二步把数据从内核缓冲区复制到应用进程缓冲区。

*** 同步与异步的区别
+ 同步I/O操作：导致请求进程阻塞，直到I/O操作完成；异步I/O操作：不导致请求进程阻塞。（关键是第二步）
+ 阻塞，非阻塞：进程/线程要访问的数据是否就绪，进程/线程是否需要等待；
+ 同步，异步：访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。

*** 同步模型（synchronous I/O）
**** 阻塞I/O（bloking I/O）
+ 进程发起 recvform 系统调用，然后进程就被阻塞了，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据。
+ 在等待数据到处理数据的两个阶段，整个进程都被阻塞。
+ 阻塞IO的特点就是在IO执行的两个阶段都被block了
**** 非阻塞I/O（non-blocking I/O）
+ 也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error
+ 轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。
+ 拷贝数据整个过程，进程仍然是属于阻塞的状态
+ 非阻塞 IO的特点是用户进程需要不断的主动询问kernel数据是否准备好。
**** 多路复用I/O（multiplexing I/O）
多路复用的特点是通过一种机制一个进程能同时等待多个IO文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。
对于监视的方式，又可以分为 select， poll， epoll三种方式。

I/O多路复用的最大优势是系统开销小

第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。
第二个阶段都是阻塞的
***** select
内核级别的调用，能等待多个socket，并能同时实现对多个 IO 端口的监听。

当其中任何一个 socket 准备好了，就能返回进行可读，然后进程进行 recvform 系统调用，
将数据由内核拷贝到用户进程，当然这个过程是阻塞的。
***** poll
poll的实现和select非常相似，只是描述fd集合的方式不同，
***** epoll
+ epoll既然是对select和poll的改进
+ 而epoll提供了三个函数:
  + epoll_create是创建一个epoll句柄；
  + epoll_ctl是注册要监听的事件类型；
  + epoll_wait则是等待事件的产生。
**** 信号驱动式I/O（signal-driven I/O）
首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据
*** 异步I/O（asynchronous I/O）
相对于同步IO，异步IO不是顺序执行。
用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。
等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。
IO两个阶段，进程都是非阻塞的。

信号驱动I/O是由内核通知我们如何启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。
** https
https 除了 TCP 的三个包之外，还需要 ssl 握手的9个包(非对称 and 签名，对称)

安全，但会导致建立连接的速度变慢，而且增加服务器资源的消耗。
** TCP 三次握手
*** 原因
 网络存在延迟，建立连接的数据报发到服务端时可能间隔时间过长，
 此时客户端已无建立连接的请求。
*** 具体过程
+ client -> server: SYN=1,seq=client_isn
+ server -> client: SYN=1,seq=server_isn,ack=client_isn+1
+ client -> server: SYN=0,seq=client_isn+1,ack=server_isn+1

(ack确认号，数字表示期望接受的下一个序列)
** TCP 四次挥手
*** 原因
*** 具体过程
+ client shutdown
+ client -> server: FIN
+ server -> client: ACK
+ client 依据ACK补发数据包，server依据FIN，结合app需求继续发送数据包。
+ server shutdown
+ server -> client: FIN
+ client -> server: ACK
+ server 收到的ACK不对，则补发之前的包
** 如何让 UDP 实现可靠传输
+ UDP 不属于连接型协议，具有资源消耗小，处理速度快的优点。
+ 在应用层实现确认机制、重传机制、窗口确认机制。
+ 如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：
  + 发送：包的分片、包确认、包的重发
  + 接收：包的调序、包的序号确认
** HTTP 长连接短连接
*** 短连接
 连接->传输数据->关闭连接 
*** 长连接
连接->传输数据->保持连接 -> 传输数据-> ...........->直到一方关闭连接，多是客户端关闭连接。 

长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。
*** HTTP在短链接和长连接上的选择
+ 实现长连接要客户端和服务端都支持长连接。
+ HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接。
+ HTTP1.1，增加了持久连接支持(貌似最新的HTTP1.1 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。
*** 什么时候用长连接，短连接
+ 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。
+ 并发量大，但每个用户无需频繁操作情况下需用短连好。比如 web 网站的 http 服务。
*** 长短连接的比较
+ 长连接可以省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间。
+ 不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测 TCP 连接的存活。
+ 短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。
+ 但如果客户请求频繁，将在 TCP 的建立和关闭操作上浪费时间和带宽
** Cookie 和 Session
*** Session
+ HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，使用 Session 机制来识别具体的用户。
+ 保存在服务端，有一个唯一的标识。
+ Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中
+ session 的运行依赖 session id，其是存在 cookie 中的，如果浏览器禁用了 cookie，需要通过其他方法实现，比如在 url 中传递 session_id。
*** Cookie
+ 实现 Session 跟踪特定用户的方法。
+ Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
** HTTP 请求响应报文格式
*** HTTP 请求报文
一个 HTTP 请求报文由：请求行，请求头部，空行和请求数据四个部分组成。
**** 请求行
+ 请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔
+ 例如：GET /index.html HTTP/1.1
+ HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT
***** GET
+ 最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。
+ GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。
***** POST
+ POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中
***** HEAD
+ HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。
+ 当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。
***** GET 和 POST 的区别
+ GET提交，请求的数据会附在URL之后，以?分割URL和传输数据，多个参数用&连接; POST提交：把提交的数据放置在是HTTP包的包体。
+ HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。但是GET:特定浏览器和服务器对URL长度有限制。
+ POST的安全性要比GET的安全性高;通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录
**** 请求头部
+ 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。
+ 请求头部通知服务器有关于客户端请求的信息
+ 典型的请求头部有：User-Agent，Accept，Host。
**** 空行
最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。
**** 请求数据
请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。
*** HTTP 响应报文
HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行，响应正文。
**** 状态行
HTTP-Version Status-Code Reason-Phrase CRLF
+ HTTP-Version表示服务器HTTP协议的版本；
+ Status-Code表示服务器发回的响应状态代码；
+ Reason-Phrase表示状态代码的文本描述
**** 消息报头
+ key:value 形式
+ 表示响应的相关信息
** HTTP 常见状态码
*** 1开头
+ 1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码
*** 2开头
+ 2xx (成功)表示成功处理了请求的状态代码
+ 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
+ 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。
+ 206 (部分内容) 服务器成功处理了部分 GET 请求(客户端进行了范围请求)。 
*** 3开头
+ 3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
+ 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。
+ 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
+ 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。(包含的其他文件）
+ 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
+ 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
*** 4开头
+ 4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理。
+ 400 (错误请求) 服务器不理解请求的语法。
+ 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
+ 403 (禁止) 服务器拒绝请求。
+ 404 (未找到) 服务器找不到请求的网页。
*** 5开头
+ 5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。
+ 500 (服务器内部错误) 服务器遇到错误，无法完成请求。
+ 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。
* 数据库
** 数据库范式
*** 范式
一张数据表的表结构所符合的某种设计标准的级别。
*** 第一范式(1NF)
符合1NF的关系中的每个属性都不可再分

1NF是所有关系型数据库的最基本的要求
*** 第二范式(2NF)
在1NF的基础上消除了非主属性对码的部分函数依赖
**** 函数依赖
若在一张表中，在属性(或属性组)X的值确定的情况下，必定能确定属性Y的值，记X->Y。
***** 完全函数依赖
对于X的任何一个真子集X'，不存在X'->Y
***** 部分函数依赖
非完全函数依赖
***** 传递函数依赖
若Y->Z，且X->Y，那么我们称Z传递函数依赖于X。
**** 码
对于属性(或属性组)K，若除K之外的所有属性都完全依赖于K，那么我们称K为候选码。
**** 主属性
包含在任意一个码中的属性
*** 第三范式(3NF)
3NF在2NF的基础上，消除了非主属性对于码的传递函数的依赖。
*** BCNF 范式
在3NF的基础上消除了主属性对于码的部分与传递函数的依赖。

(主属性/码 过多)
* 设计模式
* 面试
** 应聘者提问
提与招聘职位或项目相关的问题。
