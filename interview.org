* Java
** 面向对象的特性
*** 抽象
+ 抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。
*** 继承
+ 继承是从已有类得到继承信息创建新类的过程。
+ 构造器不能被继承，因此不能被重写，但可以重载。
*** 封装
+ 封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。
*** 多态
**** 定义
 指允许不同类的对象对同一消息做出响应。
 即同一消息可以根据发送对象的不同而采用多种不同的行为方式。
**** 实现多态的技术
 + 方法重写：动态绑定，指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。
 + 方法重载：静态绑定，编译时的多态性
**** 重写和重载
重写的条件：
+ 参数列表必须完全与被重写方法的相同；
+ 返回类型必须完全与被重写方法的返回类型相同；
+ 访问级别的限制性一定不能比被重写方法的强；
+ 访问级别的限制性可以比被重写方法的弱；
+ 重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常
+ 重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）
+ 不能重写被标示为final的方法；
+ 如果不能继承一个方法，则不能重写这个方法。

重载的条件：
+ 被重载的方法必须改变参数列表；
+ 被重载的方法可以改变返回类型；
+ 被重载的方法可以改变访问修饰符；
+ 被重载的方法可以声明新的或更广的检查异常；
+ 方法能够在同一个类中或者在一个子类中被重载。
+ 函数重载不能依据返回类型区分是因为在调用时如果不指定类型信息，编译器不知道你要调用哪个函数。
**** 多态的作用
 消除类型之间的耦合关系
**** 多态存在的三个必要条件
 + 要有继承
 + 要有重写
 + 父类引用指向子类对象(向上转型)
*** 面向对象的六原则一法则
+ 单一职责原则
+ 开闭原则：对扩展开放，对修改关闭
+ 依赖倒转原则：面向接口编程
+ 里氏替换原则：任何时候都可以用子类型替换掉父类型
+ 接口隔离原则：接口要小而专
+ 合成聚合原则：有限使用聚合或合成关系复用代码
+ 迪米特法则：一个对象应当对其他对象尽可能少的了解
+ 总结：高内聚，低耦合
** Object方法
*** getClass
+ 返回运行时对象的Class对象
+ 是一个final方法，不允许子类重写
+ 也是一个native方法
*** hashCode
+ 该方法返回对象的哈希码，主要使用在哈希表中
+ native 方法
*** equals
+ 比较两个对象是否相等
+ Object类的默认实现是比较两个对象的内存地址
*** clone
+ 创建并返回当前对象的一个拷贝
+ 是一个 protected 的 native 方法
*** toString
+ 默认输出类的名字@实例的16进制哈希码
+ 输出简明易懂的字符串
+ 建议Object的所有子类都重写这个方法
*** notify
+ 唤醒一个在此对象监视器上等待的锁
*** notifyAll
+ 唤醒在此对象监视器上等待的所有线程
+ notifyAll 和 notify 一样只能在拥有对象监视器的所有者线程中DBA调用
*** wait
+ wait方法会让当前线程等待直到另一个线程调用对象的 notify 或 notifyAll 方法，或者超时。
+ 同样是 final 的 native 方法
+ wait 方法放弃了当前线程对象监视器上的锁
*** finalize
+ finalize方法是一个protected方法，Object类的默认实现是不进行任何操作
+ 被垃圾回收器回收前触发
** Error和Exception
*** 联系
+ 继承结构:都是从 Throwable 继承
+ Error 和 RuntimeException 及其子类都是未检查异常(unchecked exception)，其他为受检查异常。
*** 区别
+ Error 类一般指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。
+ 运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误
+ Exception 类表示程序可以处理的异常，可以俘获且可能恢复。
*** 异常
+ 每个异常都是一个对象，它是Throwable类或其子类的实例
+ Java方法抛出的可查异常将依据调用栈、沿着方法调用的层次结构一直传递到具备处理能力的调用方法
+ 最高层次到main方法为止，称为异常链
*** 异常使用原则
+ 不要将异常处理用于正常的控制流
+ 对可以恢复的情况使用受检异常，对编程错误使用运行时异常
+ 避免不必要的使用受检异常
+ 优先使用标准的异常
+ 每个方法抛出的异常都要有文档
+ 保持异常的原子性(对象的状态不因为抛出异常而改变)
+ 不要在catch中忽略掉铺获到的异常
*** checked和unchecked
+ checked:通常是从一个可以恢复的程序中抛出来的，并且最好能够从这种异常使用中恢复。
+ unchecked:通常是如果一切正常的话，就不该发生的异常。
*** try,catch,finally
+ try:无论是否俘获异常，其后可以接零个或多个catch块，如果没有catch块，则必须跟一个finally块
+ 每当遇到一个try语句，异常的结构就放入异常链中
+ catch:用于处理try铺获到的异常
+ finally:无论是否铺获异常，finally中的语句都会被执行，除了以下四种情况
  + 在finally语句块中发生异常
  + 在前面的代码中用了System.exit()退出程序
  + 程序所在的线程死亡
  + 关闭CPU
+ 如果finally中拥有return 或改变之前的返回值，将会导致和预期相违背的情况出现
*** try-with-resources
+ Java7 增加了资源管理语法，来自动化管理资源
+ TWR改善了错误跟踪的能力，能够更准确地跟踪堆栈中的异常
+ 使用TWR语法的类需要实现AutoCloseable接口
+ 在某些情况下资源不能关闭
+ 要确保try-with-resources生效，正确的用法是为各个资源声明独立变量

#+BEGIN_SRC java
  try(ObjectInputStream in = new ObjectInputStream(new FileInputStream("file"))) {
  }
#+END_SRC
如果file存在，但不是ObjectInput类型的文件，就无法构建ObjectInputStream，而FileInputStream也无法关闭

#+BEGIN_SRC java
  try (FileInputStream fin = new FileInputStream("file");
       ObjectInputStream in = new ObjectInputStream(fin)) {
  }
#+END_SRC
** String类
*** String类
+ String类是final类，不可以被继承
*** String, StringBuilder, StringBuffer
+ String:不可变对象
+ StringBuilder：可变，线程不安全，适用于单线程且值易变的场景
+ StringBuffer: 可变，线程安全，适用于多线程的场景
*** 常见面试题
#+BEGIN_SRC java
  String s1 = "abc";
  String s2 = "a" + "bc";
  System.out.println(s1 == s2);
#+END_SRC
结果为true，java对s2进行了编译时期的常量优化。

#+BEGIN_SRC java
  String s1 = "ab";
  String s2 = "abc";
  String s3 = s1 + "c";
  System.out.println(s3 == s2);
#+END_SRC
结果为false，变量s1与常量"c"相加，底层是通过StringBuilder的append和toString来完成的。
对变量s1与变量s2的相加其等同于(new StringBuilder(String.valueOf(s1))).append(s2).toString();

#+BEGIN_SRC java
  String a = "hello2";
  final String b = "hello";
  String c = b + 2;
  System.out.println(a == c);
#+END_SRC
结果为true，因为对于final修饰的变量，会在编译期被替换为真实的值。

#+BEGIN_SRC java
  String str = "abc";
  str.concat("123");
  System.out.println(str);
#+END_SRC
结果为"abc"，由于字符串是常量，该类中的所有方法都不会改变字符串的值。

#+BEGIN_SRC java
  String s = "hello";
  char c[] = {'h', 'e', 'l', 'l', 'o'};
  System.out.println(s==t);
#+END_SRC
结果为false，String类重写了equals方法，类型不同返回 false。

#+BEGIN_SRC java
  String s = new String("abc");
#+END_SRC
该语句涉及两个对象，其首先在常量池中查找，
之后再在内存的堆中创建s对象。

#+BEGIN_SRC java
  String s = new String("abc");
  String s1 = "abc";
  System.out.println(s == s.intern());
  System.out.println(s1 == s.intern());
#+END_SRC
结果为false，true，intern()方法返回的是字符串对象的规范化形式，具体是对应的常量池中的对象。
*** char型变量能不能存储一个中文汉字
+ char型可以存储一个中文汉字，因为Java中使用的编码是Unicode，一个char占两个字节，所以放中文没问题
+ 使用Unicode意味着字符在JVM内部和外部有不同的表现形式，在内部都是Unicode，进出时需要编码转换
+ Java 中的转换接口有InputStreamReader和OutputStreamReader
*** 将GB2312编码的字符串转换为ISO-8859-1编码的字符串
#+BEGIN_SRC java
  String s2 = new String(s1.getBytes("GB2312"), "ISO-8859-1");
#+END_SRC
*** 正则表达式
+ String 类支持 matches(), replaceAll(), replaceFirst(), split()等方法
+ Java 类还可以使用Pattern类来表示正则对象

#+BEGIN_SRC java
  Pattern p = Pattern.compile(".*?(?=\\()");
  Match m = p.matches(str);
#+END_SRC
** 基本类型与包装类
*** 基本类型
+ 基本类型有8个：byte、short、int、long、float、double、char、boolean。
+ 除了基本类型和枚举类型之外，剩下的都是引用类型
*** 包装类
 + 包装类的 "==" 运算在不遇到算术运算的情况下不会自动拆箱
 + 包装类的 equals() 方法不处理数据转型
*** int 与 Integer
+ int是一种原始类型，其保存的是真实的二进制数值
+ Integer是一个java.lang.Integer类型的对象
**** int和Integer之间的选择
+ 有性能要求时使用int
+ 需要使用对象的方法隐式要求使用Integer
+ 对于处于(-128~127)之间的数字，由于object interning的原因，使用起来代价更低，此时应使用Integer.valueOf(int)而不是new Integer(int).
+ 缓存的范围大小可以通过AutoBoxCacheMax来进行调整
+ 对于 Integer 类型，不要使用 == 或 != 。
+ 考虑使用 Integer 当你需要考虑表示缺失数值时(null)。
**** int和Integer之间的不可互换
+ boolean List.remove(Object findThis):删除第一个和参数equals的对象
+ Object List.remove(int index):删除在指定位置的对象，并返回该对象
+ int 类型的自动装箱会调用 Integer.valueOf(int)
+ Integer 变量指向一个内存地址
+ 在(-127~128)之间的Integer变量使用valueOf所缓存的值
+ 在上述范围之外的Integer变量则会触发new Integer(int)
+ 对于表达式 boolean ? int : Integer 或者 boolean? Integer : int，Integer总是被拆箱成int.
+ 当比较一个Integer对象和一个int时，会对Integer自动拆箱
+ 当使用Integer.equals(int)时，会对int类型自动装箱成Integer类。
**** Integer
+ 比较两个Integer对象是否相等，好的做法是x.equals(y) 或者 x.intValue() == y.intValue()
*** 字符串与基本类型
+ 任意基本类型均可与字符串进行转换
+ 调用基本数据类型对应的包装类方法parseXXX(String)或valueOf(String)即可
+ 将基本数据类型与空字符串连接(+），或者调用String类的valueOf()方法
*** float
+ float f=3.4; 是错误的，其应改成float f = (float)3.4;或者float f= 3.4F;。
*** math 方法
+ floor:向下取整
+ ceil:向上取整
+ round:加0.5然后向下取整；11.5->12,-11.5->-11
** 运算符
*** & 与 &&
+ & 的用法：1)按位与；2)逻辑与(不发生短路操作)。
+ && 短路运算符
** 克隆与序列化
*** 实现克隆的方式
+ 实现Cloneable接口并重写Object类中的clone()方法
+ 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现深度克隆
+ 基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，编译器可以检查出要克隆的对象是否支持序列化
*** 序列化
 + 要求在 JVM 停止运行之后能够保存指定的对象，并在将来重新读取保存的对象。
 + 使用Java对象序列化，在保存对象时，会把状态保存为一组字节。
 + 对象序列化保存的是对象的“状态”，即它的成员变量。其不会关注类中的静态变量。
 + 在Java中，只要类实现了 Serializable 接口，那么它就可以被序列化。
 + 如果父类想要序列化，就让父类也实现 Serializable 接口。
 + 通过 ObjectOutputStream 和 ObjectInputStream 来对对象进行序列化和反序列化。
 + 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，还需要序列化的类和本地实体类的序列化ID一致。
 + Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件。在反序列化后，transient 变量的值被设置为初始值0,null。
 + 在类中增加 writeObject 和 readObject 方法可以实现自定义序列化策略。
 + 序列化除了可以实现对象的持久化之外，还能够用于对象的深度克隆
** Java 字符流
+ 字节流：InputStream, OutputStream
+ 字符流：Reader, Writer
+ 使用：
  + 对称性：输入和输出的对称性，字节和字符的对称性
  + 适配模式
  + 装饰模式
** Java NIO
*** 目的
使用高速 IO 而无需编写自定义的本机代码。
将最耗时间的 IO 操作(提取和转移缓冲区)转移回操作系统。
*** 与传统 IO 的比较
+ NIO 是面向块的，IO 是面向流的。
+ 传统 IO：简单优雅，但速度慢
*** 核心对象
**** 通道与缓冲区
***** 通道(channel)：对原 IO 包的流的模拟。
***** 缓冲区(buffer)：
 + Position:当前位置
 + Limit:最大可读/写的位置
 + Capacity:总容量
 + flip 方法通过改变Position和Limit的值来切换读写
**** 非阻塞 IO
Java NIO 可以让你非阻塞地使用 IO
**** 选择器
+ 单个线程可以监听多个通信信道的事件
+ 注册 IO 事件的地方
*** 应用场景
+ 高性能，高容量服务端应用程序
+ 网络协议的解析，TCP 拆包，粘包
+ 远程过程调用 RPC
+ C10K 问题:在有1万个同时连接时，传统的阻塞的，每个连接一个线程的网络处理方式存在的问题
*** non-blocking
如果要启用non-blocking模式的 IO 操作，
可以很方便的通过 configureBlocking 来设置。
*** IO 多路复用模式
一般来说，IO多路复用机制需要使用事件分发器，来将读写事件源分发给读写事件本示例来的处理者。
**** Proactor
+ 基于异步 IO 的。
+ 事件处理者直接发起一个异步读写操作，而实际的工作是由操作系统来完成的。
+ 事件分发器得到这个请求，默默等待这个请求的完成，然后转发完成事件给相应的事件完成者或回调。
+ 你给我收十个字节，收好了你跟俺说一声
***** 操作步骤
1.等待事件到来（Proactor负责）。
2.得到读就绪事件，执行读数据（现在由Proactor负责）。
3.将读完成事件分发给用户处理器（Proactor负责）。
4.处理数据（用户处理器负责）。
**** Reactor
+ 基于同步 IO
+ 事件分发器等待某个事件或者某个可应用或可操作的状态的发生。
+ 转发给事先注册的回调，来做实际的读写操作。
+ 能收了你跟俺说一声
***** 操作步骤
1.等待事件到来（Reactor负责）。
2.将读就绪事件分发给用户定义的处理器（Reactor负责）。
3.读数据（用户处理器负责）。
4.处理数据（用户处理器负责）。

** JVM 垃圾收集
*** 对象死亡了吗
+ 引用计数法
+ 可达性分析
*** 垃圾回收算法 
+ 标记-清除算法
+ 复制算法
+ 标记-整理算法
+ 分代收集算法
*** HotSpot 算法优化
**** 枚举根节点
在可达性分析中，使用 OopMap 记录引用位置及类型。
**** 安全点
只在特定的点生成 OopMap -- 节省空间。
**** 安全区域
将安全点拓展到区域上 -- 防止无法响应 JVM 的中断请求。
*** 垃圾收集器
**** Serial 收集器
+ 单线程，Client模式下的默认新生代收集器，简单高校。
+ 新生代采用复制算法，老年代采用标记整理算法
**** ParNew 收集器
+ 多线程，在单 CPU 下效果不好，在多个 CPU 情况下效果好。
+ 新生代采用复制算法，老年代采用标记整理算法
**** Parallel Scavenge 收集器
+ 目的：达到一个可控制的吞吐量。
+ GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的。
+ GC 自适应调整策略：通过检测来调整。
+ 采用复制手机算法
**** Serial Old 收集器
**** Parallel Old 收集器
Parallel Scavenge 的老年代版本。
**** CMS 收集器
+ 目的：获取最短回收停顿时间为目标。
+ 采用标记清理
+ 优点：并发收集，低停顿。
+ 缺点：
  + 对 CPU 资源敏感
  + 无法处理浮动垃圾
  + 大量空间碎片(标记-清楚）
**** G1 收集器
+ 新生代老年代通吃。
+ 采用标记整理
+ 特点：
  + 并行与并发
  + 分代收集
  + 空间整合
  + 可预测的停顿
+ G1 跟踪各个 Region 里面的垃圾收集堆积的价值大小。
+ 在 G1 收集器中使用 Remembered Set 来避免全堆扫描。
+ 在刷选阶段，根据用户所期望的 GC 停顿时间来制定回收计划。
+ 如果你的应用追求低停顿，那就可以选择 G1。
*** 内存分配与回收策略
不管是在新生代还是老年代，其内存不够时，发起Minor GC/Full GC。
**** 新生代
一般分为 Eden 和 Survivor（两个，轮换使用），8：1
**** 老年代
+ 大对象直接进入老年代
+ 长期存活的进入老年代
+ 动态对象年龄
*** JVM 垃圾回收相关参数
+ Xms/Xmx 堆的初始大小/堆的最大大小
+ Xmn 堆中年轻代的大小
+ XX:-DisableExplicitGC 屏蔽System.GC()
+ XX:+PringGCDetails 打印GC细节
+ XX:+PrintGCDateStamps 打印GC操作的时间戳
+ XX:NewSize/XX:MaxNewSize 设置新生代大小/最大大小
+ XX:NewRatio 设置老生带和新生代的比例
+ XX:PrintTenuringDistribution 设置每次新生代GC后输出Surviors区中对象年龄的分布
+ XX:InitialTenuringThreshold/XX:MaxTenuringThreshold 设置老年代阈值的初始值和最大值(年龄，两个值方便动态调整)
+ XX:TargetSurviorRatio 设置Surviors的目标使用率(默认50%)
** hashCode 与 equals 方法
*** equals 的作用
+ 用来判断两个对象是否相等
+ 在 JDK 中，通过判断两个对象的地址是否相等来区分它们是否相等
+ 可以依据需要对方法进行覆盖（如果没有覆盖，其作用和 == 相同）
*** 使用 equals 的诀窍
+ 使用 == 操作符检查参数是否为这个对象的引用
+ 使用 instanceof 操作符检查参数是否为正确的类型
+ 对于类中的关键属性，检查参数传入对象的属性是否与之想匹配
+ 编写完equals方法后，问自己它是否满足对称性，传递性，一致性
+ 重写equals方法时，总是要重写hashCode
+ 不要将equals方法参数中的Object对象替换为其他的类型，在重写时不要忘掉@Override注解
*** hashCode 的作用
+ hashCode 的作用是获取哈希码，也称为散列码；它实际返回一个 int 整数。
*** equals 和 hashCode 之间的关系
**** 不会创建类对应的散列表
+ 不会在 HashSet HashTable HashMap 等本质上是散列表的数据结构中用到该类。 
+ 此时 hashCode 和 equals 无关。
**** 会创建类对应的散列表
+ 如果 equals 判断两个对象相等，则 hashCode 一定相等。
+ 如果两个对象的 hashCode 相等，其 equals 不一定判断相等。
+ 如果覆盖了 equals 方法，也需要覆盖对应的 hashCode 方法，否则散列表中将存在重复值。
** Java类与对象
*** Java类启动
 + 父类静态字段和静态代码段
 + 子类静态字段和静态代码段
 + 父类成员字段和代码块
 + 父类构造器
 + 子类成员字段和代码块
 + 子类构造器

#+BEGIN_SRC java
  Class A {
      static {
          System.out.print("1");
      }
      public A() {
          System.out.print("2");
      }
  }

  Class B extends A {
      static {
          System.out.print("a");
      }
      public B() {
          System.out.print("b");
      }
  }

  public class Hello{
      public static void main(String[] args) {
          A ab = new B();
          ab = new B();
      }
  }
#+END_SRC
结果为1a2b2b
*** 参数传递
+ Java语言的方法调用只支持参数的值传递
+ 当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用
+ 对像的引用可以在被调用过程中被改变，但对对象引用的改变是不会影响对调用者
*** 抽象类和接口
共同点：
+ 不能够实例化
+ 可以定义引用类型
区别：
+ 接口比抽象类更加抽象，抽象类可以定义构造器，可以抽象方法和具体方法
+ 抽象类中的成员可以是private、默认、protected、public的，而接口中的成员都是抽象方法
+ 抽象类中可以定义成员变量，而接口中的成员变量实际都是常量
+ 有抽象方法的类必须被声明为抽象类
+ 接口继承接口，抽象类实现接口
*** 静态嵌套类和内部类
**** 静态嵌套类
+ 静态嵌套类是被声明为静态的内部类，它可以不依赖外部类实例被实例化
+ 如果一个类要被声明为static的，只有一种情况，就是静态内部类
+ 而通常的内部类需要在外部类实例化之后才可以实例化
+ 静态嵌套类无法访问外部类的非静态成员
+ 当外部类需要使用内部类，而内部类无需外部类资源时，可以使用静态类
+ 当类的构造器或静态工厂中有多个参数，最好使用Builder模式(withxxx设置参数)，特别是当大多数参数是可选的时候
#+BEGIN_SRC java
  Class Outer {
      class Inner{}
      public static void main(String[] args) {
          new Outer.new Inner();
      }
  }
#+END_SRC
**** 三种内部类
***** 常规内部类
+ 内部类可以直接访问外部类的成员变量和方法(包括私有对象)，利用这个特性可以实现多继承的效果
+ 内部类提供了更好的封装，除了该外围类，其他类都不能访问
***** 局部类
+ 如果想要使用内部类，必须在同一方法中实例化内部类
+ 只有abstract和final这两个修饰符被允许修饰局部内部类(默认与局部变量的作用域相同)
+ 只有在方法的局部变量被标记为final或局部变量是effectively final(当变量或参数在初始化之后，值再也没改变过)的，内部类才能使用它们
+ 局部内部类只在方法体中有效
***** 匿名类
特点:
+ 没有名字
+ 只能被实例化一次
+ 通常被声明在方法或代码块的内部，以一个带有分号的花括号结尾
+ 因为没有名字，所以没有构造函数
+ 不能是静态的
+ 常被用来简化代码

常用场景：
+ 事件监听
+ Thread 类的匿名内部实现
+ Runnable 类的匿名内部类实现

代码示例：
#+BEGIN_SRC java
  addWindowListener(
                    new WindowAdapter() {
                        public void windowClosing(WindowEvent e) {
                            System.exit(0);
                        }
                    }
                    );
#+END_SRC
*** 抽象方法
+ 抽象方法需要子类重写，所以不可能是静态的
+ 其是没有实现的，所以不可能是本地方法或同步方法
*** 静态变量和实例变量
+ 静态变量是被static修饰的，也称类变量，在内存中只有一个拷贝，可以被多个对象共享
+ 实例变量必须依存于某一个实例，并且需要通过实例才能访问
*** final关键字
+ 修饰类：表示该类不能被继承
+ 修饰方法：表示方法不能被重写
+ 
*** 获取类对象的方式
+ String(类型).class
+ obj.getClass()
+ Class.forName("java.lang.String"(类名))
*** 使用反射创建对象
+ 无参数: String.class.newInstance()
+ 带参数: String.class.getConstructor(String.class).newInstance("Hello")
*** 通过反射获取和设置私有对象私有字段
+ 通过类对象的getDeclaredField方法获取字段对象
+ 通过字段对象的setAccessible(true)来将其设置为可以访问
+ 通过get/set方法来获取/设置字段的值
** 集合类
+ 集合类主要分为Collection和Map这两类
+ Iterator是遍历集合的迭代器(不能用来遍历Map,只能用来遍历Collection)
+ Arrays和Collections是用来操作数组，集合这两个工具类
*** Collection
**** List
+ list 中允许空元素的存在
***** ArrayList
+ 数组结构
+ 线程不安全
+ 查询速度快
+ 增加，删除速度较慢
+ 支持序列化
+ 新容量=原容量×1.5+1
****** 和 Array 比较
+ Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象
***** LinkedList
+ 链表结构
+ 线程不安全
+ 查找速度慢，消耗更多内存
+ 增加、删除速度较快
***** CopyOnWriteArrayList
  + 任何对array结构上有所改变的操作，CopyOnWriteArrayList都会copy现有的数据，再在copy的数据上修改，完成后改变原有数据的引用。
  + 读操作不用加锁，写的时候先加锁防止并发问题
  + 这样造成的代价是产生大量的对象，同时数组的 copy 也是相当有损耗的。
  + 其和 ArrayList 一样，都是实现了List接口，底层使用数组实现。
***** Vector
+ 数组结构
+ 线程安全
+ 已被 ArrayList 取代
+ 不支持序列化
+ 扩容与增长系数有关
+ 支持通过 Enumeration 遍历
***** Stack
+ 栈，继承 Vector
**** Set
+ 三个Set实现都是非线程安全的
+ 三个Set实现的迭代器返回均为Fail-fast迭代器
+ 速度方面：HashSet > LinkedHashSet > TreeSet
***** HashSet
+ 元素存放顺序和添加进去的顺序没有关系
+ 按照哈希算法来存取集合中的对象，存取速度比较快
+ 最多包含一个null元素
+ 内部实现使用了 HashMap 对象
***** LinkedHashSet
+ 保持元素的添加顺序
+ 以元素插入的顺序来维护集合的链接表
+ 内部实现使用了 HashSet 和 LinkedList
***** TreeSet
+ 对Set中的元素进行排序存放
+ 内部实现使用了 TreeMap
***** CopyOnWriteArraySet
+ 并发集合包
**** Queue
+ Queue 接口继承自 Collection 接口，并对其进行了窄化
+ 简单的可以使用 LinkedList 来实现
***** BlockingQueue
+ 在进行检索或移除一个元素时，它会等待队列变为非空
+ 在添加一个元素时，它会等待队列中有可用空间
+ 主要用于实现生产者-消费者模式
+ 有 ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue 等
***** ConcurrentLinkedQueue
**** Iterator 和 Enumeration
在 Java 集合中，我们通常使用迭代器和枚举类来遍历集合。

#+BEGIN_SRC java
  public interface Enumeration<E> {
      boolean hasMoreElements();
      E nextElement();
  }
#+END_SRC

#+BEGIN_SRC java
  public interface Iterator<E> {
      boolean hasNext();
      E next();
      void remove();
  }
#+END_SRC

+ 函数接口不同，通过 Enumeration ，我们只能读取集合的数据，而不能对其进行修改。而 Iterator 能对其进行删除操作。
+ Iterator支持fail-fast机制，而 Enumeration 不支持该机制，也不支持同步，但在 Vector,Hashtable 中实现 Enumeration 时，添加了同步。
+ Enumeration 的速度是 Iterator 的两倍，且使用更少的内存。
**** fail-fast机制
+ fail-fast机制是java集合中的一种错误机制。但多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。
+ 其通过检测 modCount 变量来判断集合在遍历过程中是否发生修改，如果是则抛出异常 java.util.ConcurrentModificationException 。
+ 迭代器的快速失败行为是无法得到保证的，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。
+ 为提高这类迭代器的正确性而编写一个以来于此异常的程序是错误的做法，其仅用于检测bug。
+ 在并发场景下，推荐使用线程安全的类，其采用的是 fail-safe 方式设计。
+ 在 Collection 中所有 Iterator 的实现都是按 fail-fast 来设计的。
**** Comparable 和 Comparator 接口
***** Comparable 自然排序
#+BEGIN_SRC java
  public interface Comparable<T> {
      public int compareTo(T o);
  }
#+END_SRC

+ Comparable 可以让它的类的对象进行比较，具体的比较规则是按照 compareTo 的方法中的规则进行，称为自然排序。
+ compareTo 方法的返回值：
  + e1.compareTo(e2) > 0 即 e1 > e2
+ 需要注意 e.compareTo(null) 的情况，即使 e.equals(null) 返回 false，compareTo 方法也应该主动抛出一个空指针异常。
+ 一般要求 e1.compareTo(e2)==0 的结果要和 e1.equals(e2) 一致。这样将来使用 SortedSet 根据类的自然排序进行排序时的集合容器保存的数据的顺序和想象中一致。
+ compareTo 决定的是元素在排序中的位置是否相等，equals 决定的是元素是否相等，如果前者相等，那么后者也应相等。
***** Comparator 定制排序
#+BEGIN_SRC java
  public interface Comparator<T> {
      public int compare(T lhs, T rhs);
      public boolean equals(Object object);
  }
#+END_SRC

+ 使用 Comparator 是在外部指定排序规则，然后作为排序策略参数传递给某些类
+ equals 方法可以不实现，因为任何类默认都是已经实现了 equals(Object obj) 的。
+ Comparable 是在实体类进行改变，而 Comparator 则是当无法修改实体类时，直接在调用方创建。
**** 特殊集合
+ Collections.unmodifiableCollection(Collection c)
+ Collections.synchronizedCollection(Collection c)
+ Collections.synchronizedList(List ls)(需要在遍历时，对整个链表加锁)
*** Map
+ Map 接口提供了三个集合视图：
  + Set keyset()
  + Collection values()
  + Set<Map.Entry<K,V>> entrySet()
+ 对于内部类 Entry，其包含三个方法：
  + Object getKey()
  + Object getValue()
  + Object setValue()
**** hashmap 和 hashtable
***** 关于HashMap的一些说法
+ HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。
+ 在1.8中采用了数组+链表+红黑树的结构
  + 当数组的大小超过64,且链表的元素个数超过默认设定(8)时，链表转为红黑树
+ HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子
+ HashMap实现不同步，线程不安全。  HashTable线程安全
+ HashMap中的key-value都是存储在Entry中的。
+ HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性
+ 解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。

注： 链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位；
   用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。
  拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。
***** Hashtable和HashMap的区别
+ 继承不同。 public class Hashtable extends Dictionary implements Map; public class HashMap extends  AbstractMap implements Map
+ Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。
+ Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断。
+ 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。
+ HashMap 中的 Iterator 是 fail-fast 迭代器，而 HashTable 中的 Enumeration 不是。
+ 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。
+ Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。
+ HashMap 不能保证随着时间的推移Map中的元素次序是不变的。(hashtable应该同样是？)

注：  HashSet子类依靠hashCode()和equal()方法来区分重复元素。
     HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。
***** 常见面试题
****** HashMap 的 get() 方法的工作原理
+ 先对键调用 hashCode() 方法，返回的 hashcode 用来找到存储 Map.Entry 链表的 bucket 。
+ 接着使用 key.equals()方法来找到链表中正确的节点 ，来找到对象。
+ 使用基于 hash 的集合时，我们必须保证键的状态不变。
****** 如果 HashMap 的大小超过了负载因子(load factor)定义的容量
+ 默认的负载因子为0.75
+ 当一个 map 填满了 75% 的bucket时，将会创建一个原来 HashMap 大小两倍的 bucket 数组
+ 并将原来的对象放入 bucket 数组中，这个过程叫 rehashing，因为它调用 hash 方法找到新的 bucket 位置。
****** HashMap 中的竞争条件
#+BEGIN_SRC java
for (int j = 0; j < src.length; j++) {
  Entry e = src[j];
  if (e != null) {
    src[j] = null;
    do {
    Entry next = e.next;
 // Thread1 STOPS RIGHT HERE
    int i = indexFor(e.hash, newCapacity);
    e.next = newTable[i];
    newTable[i] = e;
    e = next;
  } while (e != null);
  }
} 
#+END_SRC
+ 线程1 停在所示点处
+ 线程2 完成 rehashing 步骤，添加的元素放在链表的头部
+ 此时会产生死循环
****** 哪些对象适合做键
+ String, Integer 这类不可变，且为 final，并且重写了 equals() 和 hashCode() 方法的 Wrapper
+ 需要遵从 equals() 和 hashCode() 方法的定义规则，并且当对象插入 Map 中之后，就不会再改变了
**** hashtable 和 concurrenthashmap
***** 区别
+ 两者的区别主要是性能上的差异
+ Hashtable 的所有操作都会锁住整个对象
+ Hashtable 属于 Collection 框架，而 ConcurrentHashMap 属于 Excutor 框架
+ ConcurrentHashMap 的 Iterator 是 fail-safe 的
+ 1.8 之前采用的是 Segment 的设计，之后采用的是 Node+CAS+Synchronized
***** ConcurrentHashMap
****** Segment
+ ConcurrentHashMap 内部使用 Segment 数组，每个 Segment 都类似于 Hashtable ，在写线程或部分特殊读时会锁住某个 Segment 对象
+ ConcurrentHashMap 的读操作会很快返回最新一次更新之后的结果值
+ Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 中扮演锁的角色 
+ ConcurrentHashMap 中包含一个 Segment 数组，Segment 中包含一个 HashEntry 数组
+ 每个 HashEntry 是一个链表结构
****** Node + CAS + Synchronized
******* get 过程
+ 依据 k 计算出 hash 值，找到对应的数组 index
+ 如果该 index 位置无元素则直接返回 null
+ 如果该 index 有元素
  + 如果第一个元素equals是，则返回第一个节点的值
  + 如果是红黑节点 TreeBin，使用红黑树查找
  + 如果第一个元素的 hash 大于等于0,则遍历链表
******* size 方法
+ 由于 ConcurrentHashMap 在统计 size 时可能被多个线程操作，而我们又不能让他们停下来，所有只能计算出一个估计值
******* put 方法
+ 判空：null
+ 计算hash
+ 遍历 table
  + 如果 table 为空，则初始化
  + 计算当前 key 存放位置
  + 若该位置为 null，casTabAt 无锁插入，如果插入失败则继续
  + 若是 forwarding nodes，则帮助其扩容
  + 否则首先对头节点上锁，并依据是链表还是树插入，链表尾部插入
******* 扩容方法 transfer
无锁多线程扩容
+ 核心为 ForwardingNode，当遍历点的 hash 值为-1时，表示正在扩容。当该node完成扩容后，遍历下一个node扩容
+ 还有一个关键的参数为 stride，其表示每个处理器处理的最小node个数，一般为16
+ 开始后，对该线程使用 CAS 设置 transferIndex，如果原表的大小为64，此时 transferIndex 设置为48，该线程对48-64的数组扩容
+ 对于每个正在扩容的node，需要上锁，防止并发冲突
+ 对于链表来说，扩容中的一个技巧是利用原来的hash值计算每个节点的 hash&n
  + 因为bucket是通过hash&n-1来计算的，如果n-1为11..1，那么n为10..0
  + 其设置第一个节点的计算结果为 runBit，与 runBit 相反的计算结果的从最后一个节点开始连续的链表头为 lastRun
  + 之后依据runBit的值，分别设置ln和hn的值为null和lastRun
  + 之后从头向lastRun遍历，并添加到新表中
  + 假设链表i中存储1-2-3-4-5-6-7，其对应的计算为0-1-0-1-0-1-1
  + 5-3-1 存储在链表i中
  + 4-2-6-7存储在链表i+n中
+ 对于红黑树来说
  + 遍历红黑树，依据计算值分别插入lo和hi的树中
  + 如果lo链表的元素个数小于等于阈值，则转换为链表
  + 否则判断hi中的元素个数是否大于0,等于的话就直接将原始树赋值给ln
  + 对hi进行和之前两步相对等的判断

扩容的触发条件
+ 如果新增节点之后，所在链表的元素个数达到了阈值8，则使用 treeifyBin 将链表转换成红黑树
+ 在实际转换之前，会对数组长度进行判断，如果数组长度小于阈值则，调用 tryPresize 把数组长度扩为两倍，并触发 transfer 方法重新调整节点位置
+ 新增节点后，会调用 addCount 方法记录元素个数，并检查个数阈值是否需要进行扩容

扩容操作分为两个部分
+ 第一部分是构建一个nextTable，它的容量是原来的两倍，这个操作是单线程完成的。这个变量是通过 RESIZE_STAMP_SHIFT 这个常量经过一次运算来保证的。
+ 第二部分是原来 table 的元素复制到 nextTable 中，这里允许多线程操作。

** 多线程方法
*** wait 和 sleep 的区别
 + sleep 是 Thread 类的方法，wait 是 Object 类中定义的方法。
 + sleep 不会导致锁行为的改变。而 wait 是会释放锁的。（可认为锁的方法都在 Object 类中）
 + 调用 wait 之后，需要别的线程调用 notify/notifyAll 才能重新获得 CPU 执行时间。
*** sleep 和 yield 的区别
+ sleep不考虑线程优先级，而yield只会给相同优先级或更高优先级的线程机会
+ 线程sleep方法后转入阻塞状态，而执行yield后转入就绪状态
+ sleep方法有InterruptedException异常，而yield没有任何异常
+ sleep比yield具有更好的可移植性(与CPU调度有关)
*** 同步与异步
+ 当系统中面临临界资源时，数据需要同步存取
+ 当应用程序在对象上调用花费较长时间的方法时，可以采取异步操作
*** 线程的基本状态
+ Running:运行状态
+ Runnable:就绪状态
+ Blocked:阻塞状态
  + Blocked: 调用sleep方法或join方法或I/O中断等待休眠或其他线程结束
  + Blocked in Object's Wait Pool:调用wait方法进入等待池
  + Blocked in Object's Lock Pool:调用同步方法或同步代码块进入等待池
*** Java多线程实现的方式
**** 继承Thread类
 + Thread类本质上是实现了 Runnable 接口的一个实例。
 + 使用Thread类的start()实例方法启动新线程。
**** 实现 Runnable 接口
 + 可继承其他类
**** 实现 Callable 接口通过 FutureTask 包装器来创建 Thread 线程
**** 使用 Executor 框架进行线程的创建及管理
*** synchronized 和 java.util.concurrent.locks.Lock
+ Lock可以完成synchronized所实现的所有功能
+ Lock有比synchronized更精确的线程语义和更好的性能
+ synchronized自动释放锁，而Lock一定要手工释放，并且最好在finally中释放
** 同步工具类
*** 闭锁
+ CountDownLatch
+ 计数器
+ 可以延迟线程的进度直到到达终止状态
*** FutureTask
+ Callable
+ 三个状态：等待运行、正在运行和运行完成
+ Future.get 的行为取决于任务的状态
+ 异步任务
*** 信号量
+ acquire, release
+ 用来控制同时访问某个特定资源的操作数量
*** 栅栏
+ 所有线程必须同时到达栅栏位置，才能继续执行。
+ 闭锁用于等待事件，而栅栏用于等待其他线程。
** 线程池
+ 利用线程池可以大大减少在创建和销毁线程上所花的时间以及系统资源的开销。
+ 在创建和销毁对象的过程中：
  + 获取内存资源
  + 虚拟机需要跟踪对象
  + 销毁后需要垃圾回收
*** 好处
+ 降低资源消耗
+ 提高响应速度
+ 提高线程的可管理性
*** ThreadPoolExecutor
+ 它是抽象类 AbstractExecutorService 的一个实现

#+BEGIN_SRC java
  public ThreadPoolExecutor(int corePoolSize,
                            int maximumPoolSize,
                            long keepAliveTime,
                            TimeUnit unit,
                            BlockingQueue<Runnable> workQueue,
                            ThreadFactory threadFactory,
                            RejectedExecutionHandler handler) {
  }
#+END_SRC
*** 参数
+ corePoolSize: 核心池的大小，当线程池中的任务到达 corePoolSize 后，就会把到达的任务放到缓存队列中去
+ maximumPoolSize: 线程池最大线程数
+ keepAliveTime: 表示线程没有任务执行时最多保持多久会被标记可回收，在线程数超过核心池大小时，其被回收
+ unit: 上一个参数的时间单位( DAYS, HOURS,...,)
+ workQueue: 阻塞队列，用来存储执行的任务
  + ArrayBlockingQueue 有界队列
  + LinkedBlockingQueue 无界队列
  + SynchronousQueue
+ threadFactory: 线程工厂，主要用来创建线程
+ handler: 拒绝处理任务的策略，当有界队列被填满后开始发生作用
  + AbortPolicy: 丢弃任务并抛出 RejectedExecutionHandler 异常（默认）
  + DiscardPolicy: 丢弃但不抛出异常
  + DiscardOldestPolicy: 丢弃队列最前面的任务，然后重新尝试执行任务
  + CallerRunsPolicy: 由调用线程处理该任务
*** 重要方法
**** execute
+ 当有任务进入时，线程池创建线程去执行任务，直到核心线程数满
+ 核心线程数量满了之后，任务就会进入一个缓冲的任务队列中
  + 当任务队列为无界队列时，任务就会进入一个缓冲的任务队列中，不会和最大线程数比较
  + 当任务队列为有界队列时，任务就先放入缓冲的任务队列中，当任务队列满了后，此时会与线程池中最大的线程数量进行比较，如果超出了，抛出异常。否则创建新的线程
**** shutdown
+ 判断是否可以操作目标线程
+ 设置线程池状态为 SHUTDOWN
+ 中断所以的空闲进程
+ 进入关闭状态
+ 进行退出操作
**** shutdownNow
+ 执行该方法，线程池的状态立刻变成 STOP 状态，并试图停止所有正在执行的线程，不再处理线程池队列中等待的任务，当然，它会返回未执行的任务。
+ 对于线程中没有sleep,wait,Condition,定时锁等应用，interrupt()方法是无法中断当前线程的，需要等待
*** 常用线程池
**** newFixedThreadPool
+ 创建一个定长线程池，可控制线程最大并发数
+ 使用无界队列
+ 超过的线程会在队列中等待
**** newSingleThreadExecutor
+ 创建一个单线程的线程池
+ 使用无界队列
+ 保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行
**** newCachedThreadPool
+ 创建一个可缓冲线程池
+ 如果线程池长度池超过处理需要，可灵活回收空闲线程
**** newScheduledThreadPool
+ 创建一个定长线程池，支持定时及周期性任务执行
*** 合理的配置线程池
+ 建议使用有界队列，可以增加系统的稳定性和预警能力
**** 任务的性质
+ CPU密集型,IO密集型,混合型任务
+ CPU密集型的配置尽可能小的线程，IO密集型的配置尽可能多的线程，混合型尽可能拆分成前两者
**** 任务的优先级
+ 高,中,低
+ 优先级不同的任务尽可能使用 PriorityBlockingQueue 来处理
+ 注意优先级低的任务可能会饿死
**** 任务的执行时间
+ 长,中,短
+ 可以交给不同规模的线程池来处理或者使用优先队列
**** 任务的依赖性
+ 是否依赖其他资源
+ 线程数量设置尽量大
*** 线程池的监控
+ taskCount
+ completedTaskCount
+ largestPoolSize
+ getPoolSize
+ getActiveCount
+ 可以通过继承线程池，并重写 beforeExecute，afterExecute 和 terminated 方法嵌入监控
** 高级多线程控制类
*** ThreadLocal 类
+ 保存线程的独立变量
+ 常用于用户登陆控制，如记录session信息
+ 实现：每个线程都持有一个 ThreadLocalMap 类型的变量
+ get, set, 覆盖用的initialValue方法
+ 其通过threadLocalHashCode来标识每个ThreadLocal的唯一性(CAS操作更新)
+ 存储资源是通过静态内部类 Entry 来完成的
  + 如果使用了线程池，那么线程实例处理完后很可能依旧存活
  + 通过继承 WeakReference<ThreadLocal<?>>来防止内存泄露
  + 弱引用只是针对key来说的
  + 当线程截止时，key变成一个不可达对象，这个Entry就可以被GC了
  + 当在数组型map中发生冲突时，采用线性探测法解决冲突
  + 何时无用的Entry会被清理
    + Thread结束时
    + 在插入元素时发现staled entry,则会进行替换并清理
    + 在插入元素时当size达到threshold时，并且没有任何staled entries,会调用rehash方法清理并扩容
    + 调用ThreadLocalMap的remove方法或set(null)时
  + 内存泄露
    + 最好的做法是调用threadlocal的remove方法，其还可以防止信息泄露
    + 当不存在threadLocal实例的强引用时，在ThreadLocalMap中的弱引用将会被gc回收
    + 不过如果不使用remove的话，依旧存在内存泄露的场景，当threadLocal对象设为null后，开始发生“内存泄露”，然后使用线程池，该线程结束，放回线程池不再被使用，或者分配使用了却不再调用get,set等会触发回收entry的方法
*** 原子类
*** Lock 类
+ lock 更加灵活
+ 可提供多种形式的锁方案：
  + lock 阻塞式
  + trylock 无阻塞式
  + lockInterruptily 可打断式
+ ReentrantLock 可重入锁使得持有锁的线程可以继续持有
+ ReentrantReadWriteLock 可重入读写锁，适应于读远大于写的场合
*** 容器类
+ BlockingQueue
+ ConcurrentHashMap
*** 管理类
+ 线程池 ThreadPoolExecutor
** Java线程传递数据
+ 构造方法
+ 通过变量和方法
+ 通过回调函数
** 内存
*** JVM 数据区域
 + 虚拟机栈
 + 本地方法栈：Native方法服务
 + 方法区：存储已被虚拟机加载的类信息、静态变量、即时编译器编译后的代码等数据。
 + 堆：存放对象实例。
*** 栈，堆和静态区
+ 栈空间(本地)：基本类型的对象，对象的引用，函数调用的信息
+ 堆空间：创建的对象(new,构造器）
+ 方法区：存储类结构信息的地方，其中的常量池、域、方法数据、方法体、构造函数，包括类中的专用方法、实例初始化、接口初始化都存在这个区域。这个区域是属于堆的一部分。
+ 静态常量池：编译期的数字常量字符串常量、方法或域的引用（运行时解析），属于方法区中。
*** 内存泄露
**** Java中的内存泄露 在Java中存在一些被分配的对象，虽然是无用的，但是却不被 GC 回收(可达)。
**** 容易引起内存泄露的几大原因
 + 静态集合类（里面的引用）
 + 当集合类成员的对象属性修改后，再调用remove方法不起作用(hashcode)
 + 监听器（控件增加的监听器没有及时删除）
 + 物理连接（未显示关闭，对于连接池还需显示关闭 Resultset Statement 对象）
 + 内部类和外部模块等的引用
 + 单例模式持有失效对象
**** 预防和检测内存泄露
***** 好的编码习惯
 尽早释放无用对象的引用
***** 好的测试工具
***** 分析方法
 + 需要对内存随时间不断增长的情况保持敏感
 + 触发GC,标记heap，再触发GC,标记heap并和之前的结果对比
 + 查看 FullGC 和 YoungGC 的频率，并分析其原因
 + 查看 Perm 区的变化
** Java 引用
*** 强引用
+ 不会被垃圾回收
*** 软引用
+ 和弱引用相比，它阻止垃圾回收其指向对象的能力更强一些
+ 只有当内存不足时，才会回收那些软引用可达的对象
*** 弱引用
+ 一旦弱引用对象开始返回null,该弱引用指向的对象就被标记成了垃圾
+ 只有弱引用引用的对象会被放入引用队列中，之后会进行析构以及其它清理工作
*** 虚引用
+ 不可以通过get方法获得其指向的对象
+ 其唯一作用是当其指向的对象被回收之后，自己被加入到引用队列，用作记录该引用指向的对象已被销毁
+ 其在析构过程中不会被复活
+ 使用场景
  + 允许你知道何时其引用的对象从内存中移除
  + 避免很多析构时出现的问题(一般对象在真正销毁之前需要经历析构，会产生延时)
** 断言
+ 断言用于保证程序最基本、关键的正确性
+ 断言检查通常在开发和测试中开启
+ 为了保证开发效率，发布后一般是关闭的
+ 在jvm中可以通过参数-ea,-da来开启关闭，对于系统类来说则使用-esa,-dsa。
** 与 JavaScript
区别：
+ 面向对象与基于对象
+ 解释和编译，JS(JIT即时编译优化)
+ 强类型和弱类型
* Java Web
** XML
*** 作用
+ 数据交换
+ 信息配置
** UML
+ 统一语言建模图
+ 最重要的三种图：
  + 用例图：用来铺获需求，描述系统功能，及各个模块之间的关系
  + 类图：类之间的关系
  + 时序图：描述执行特定任务时对象之间的交互关系及执行顺序，还有对象向外界提供的服务
** 数据库编程
*** JDBC
**** 步骤
 + 加载驱动
 + 创建连接
 + 创建语句
 + 执行语句
 + 处理结构
 + 关闭资源
**** 提升性能
 + 通过结果集(Resultset)对象的setFetchSize()方法指定每次抓取的记录数(空间换时间)
 + 使用PreparedStatement语句构建批处理
**** 事物处理
+ setAutoCommit(false)
+ commit()
+ rollback()
+ savePoint()
**** 对大对象的支持
+ Blob:二进制大对象，使用SetBinaryStream与PreParedStatement配合
+ Clob:大字符对象
*** Java查询语句
+ Statement：用于通用查询
+ PreparedStatement: 用于执行参数化查询
+ CallableStatement: 用于存储过程
**** PreparedStatement
+ 数据库系统会对该种sql语句预编译(如果JDBC支持的话)
+ 默认返回"TYPE_FORWARD_ONLY"类型的结果集，也可以使用preparedstatement的重载方法返回不同类型的结果集
+ 使用next方法移动结果集的游标
+ PreparedStatement可以写动态参数化查询，使用?作为占位符
+ PreparedStatement比Statement更快，语句预编译，执行计划缓存
+ PreparedStatement可以防止SQL注入式攻击(避免SQL注入的另一种方式是将传入的参数做字符取代，将两个单引号改为两个连续的单引号(视为单引号字符))
+ 可读性更好
+ 分别进行单条查询性能较差
+ 不是所有数据库都支持存储过程
+ 无法享受PreparedStatement缓存带来的好处
*** 数据库连接池
*** DAO模式
+ Data Access Object为数据库或其他持久化机制提供了抽象接口的对象
+ 在不暴露底层持久化方案实现的情况下提供各种数据访问操作
+ 在实际开发中，应该将所有对数据源的访问操作进行抽象化封装在一个公共API中
+ DAO中包含有两个模式
  + Data Accessor数据访问器: 如何访问数据
  + Data Object数据对象: 如何用对象封装数据
* Python
** Python 和多线程
Python中有一个被称为Global Interpreter Lock（GIL）的东西，它会确保任何时候你的多个线程中，只有一个被执行。

Python并不支持真正意义上的多线程。Python中提供了多线程包，但是如果你想通过多线程提高代码的速度，使用多线程包并不是个好主意。
*** GIL
+ GIL 的出现是为了解决多线程之间数据一致性和状态同步的问题。
+ 适合于 IO 密集型的问题
+ 可以通过多进程，核心部分用其他语言实现，改用其他解释器来实现
+ 多核多线程下，由于会产生线程颠簸效应（其它CPU上唤醒的线程又重新进入待调度状态）
** 静态方法和类方法的区别
*** 相同点
都可以被类或成员所访问
*** 不同点
+ 静态方法无法访问类变量和实例变量
+ 类方法可以访问类变量，但无法访问实例变量
+ 静态方法有点像函数库
+ 类方法有点像Java中的静态方法，可用做对于参数的重载
** 迭代器和生成器
*** 迭代器
**** 迭代器协议
+ 迭代器协议：对象需要提供__next__方法和__iter__(返回自己）方法，它要么返回迭代的下一项，要么就引起一个 StopIteration 异常，以终止迭代。
+ 可迭代对象：实现了迭代器协议的对象。
+ 协议是一种约定，可迭代对象实现迭代器协议，Python 的内置工具（如for循环，sum,min,max函数等）使用迭代器协议访问对象。
*** 生成器
Python 使用生成器对延迟操作提供了支持。

Python 有两种不同的方式提供生成器：
+ 生成器函数：yield（挂起）
+ 生成器表达式：类似于列表推导（使用圆括号）

生成器的特点：
+ 语法上和函数类似
+ 自动实现迭代器协议
+ 状态挂起（yield挂起该生成器函数的状态，保留足够的信息，以便继续执行）
+ 只能遍历一次
* 计算机系统
** 并发与并行
+ 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
+ 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。
** 进程，线程与协程
*** 进程与线程区别
+ 进程是资源分配的基本单位，线程是 CPU 调度/程序执行的最小单位。
+ 进程有独立的地址空间，需要维护页表等和内存缓存打交道的数据结构。
  + 进程共享状态信息比较困难，需要使用显示的 IPC 机制。
  + 线程之间的通信比较方便，使用(全局变量，静态变量等方式)。
+ 线程比进程的操作要快，花费要小。
+ 在 Linux 下本质都是 Task，需要共享的都可以选择，这两个概念上的差别被弱化了。
+ 同步与互斥的方法：临界区，事件，互斥量，信号量。
+ 多线程的好处：并发，更好的编程模型。
*** 协程
+ 非抢占式调度
+ 一般由语言层面提供
+ 用户态调度管理，开销小，切换速度快
+ 在协程中控制共享资源不加锁，只需要判断状态就好了
+ 可采用多进程+协程的方式利用多核CPU
**** goroutine
+ goroutine是 GO 语言中的轻量级实现，由Go运行时(runtime)管理。
+ 其是 GO 语言中独有的一种并发方式
+ 在一个函数前加上go关键字，这次调用就会在一个新的goroutine中并发执行。
+ 当被调用的函数返回时，这个goroutine也自动结束。
+ 在工程中最常使用共享内存和消息这两种并发通信机制。
+ M:N,M个用户线程在N个内核上运行
***** channel
消息机制认为每个并发单元是自包含的、独立的个体，并且都有自己的变量，
但在不同的并发单元间这些变量不共享。
每个并发单元的输入输出只有一种，那就是消息。
***** select
和case结合，代码优雅
***** Go runtime 的调度器
+ M:代表真正的内核OS线程，创建或从线程池里面取出的。
+ G:代表一个goroutine，它有自己的栈，pc和其他信息，用于调度。
+ P:代表调度的上下文，可以看作一个局部的调度器，使go代码在一个线程上跑。

每个M都有一个context(P)，每个P也都有一个正在运行的goroutine。
P的数量可以通过GOMAXPROCS()来设置，其代表了真正的并发度，即有多少个goroutine可以同时运行。

除了正在运行的G之外，P还维持了一个局部的队列(runqueue)，其到达一个调度点时从runqueue中取出一个G执行。

当一个线程阻塞时，即一个M阻塞，此时P可以转投另一个OS线程。
而M被唤醒后，会尝试去的一个P来运行goroutine。
如果失败，就将goroutine放在global runqueue中。

当一个P的局部runqueue和global runqueue 均执行完后，其会从其他的runqueue中获取。
** 死锁
*** 产生死锁的四个必要条件
+ 互斥条件：一个资源每次只能被一个进程使用
+ 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
+ 不可剥夺条件：进程已获得的资源，在为使用完之前，不可强行剥夺
+ 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系
*** 产生死锁的原因
+ 系统资源不足
+ 进程运行推进的顺序不合适
+ 资源分配不当
** 线程安全
一个函数是线程安全的，当且仅当其被多个并发线程反复的调用时，一直会产生正确的结果。
*** 四类线程不安全函数
+ 不保护共享变量的函数
+ 保持跨越多个调用的状态的函数
+ 返回指向静态变量的指针的函数
+ 调用线程不安全函数的函数
*** 可重入
当他们被多个线程调用时，不会引用任何共享数据。
** 进程间通信
+ 管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道还允许无亲缘关系进程间的通信；
+ 信号（Signal）：用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；
+ 报文（Message）队列（消息队列）：消息队列是消息的链接表。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
+ 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
+ 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
+ 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。
** 静态库和动态库
1 静态链接库的优点 
+ 代码装载速度快，执行速度略比动态链接库快； 
+ 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 

2 动态链接库的优点 
+ 更加节省内存并减少页面交换；
+ DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；
+ 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；
+ 适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。

3 不足之处
 + 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；
 + 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。
   而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。
   当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。
** 页面置换算法
+ 最佳置换算法(OPT)-理想置换算法
+ 先进先出置换算法(FIFO)
+ 最近最久未使用算法(LRU)
+ Clock置换算法
+ 最少使用算法(LFU)

* 计算机网络
** 网络 IO 模型
网络应用需要处理的无非就是两大类问题，网络I/O，数据计算。相对于后者，网络I/O的延迟，给应用带来的性能瓶颈大于后者

网络I/O的本质是socket的读取，socket在linux系统被抽象为流，I/O可以理解为对流的操作。这个操作又分为两个阶段：
+ 等待流数据准备（wating for the data to be ready）。
+ 从内核向进程复制数据（copying the data from the kernel to the process）。

对于socket流而已，
+ 第一步通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。
+ 第二步把数据从内核缓冲区复制到应用进程缓冲区。

*** 同步与异步的区别
+ 同步I/O操作：导致请求进程阻塞，直到I/O操作完成；异步I/O操作：不导致请求进程阻塞。（关键是第二步）
+ 阻塞，非阻塞：进程/线程要访问的数据是否就绪，进程/线程是否需要等待；
+ 同步，异步：访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。

*** 同步模型（synchronous I/O）
**** 阻塞I/O（bloking I/O）
+ 进程发起 recvform 系统调用，然后进程就被阻塞了，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据。
+ 在等待数据到处理数据的两个阶段，整个进程都被阻塞。
+ 阻塞IO的特点就是在IO执行的两个阶段都被block了
**** 非阻塞I/O（non-blocking I/O）
+ 也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error
+ 轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。
+ 拷贝数据整个过程，进程仍然是属于阻塞的状态
+ 非阻塞 IO的特点是用户进程需要不断的主动询问kernel数据是否准备好。
**** 多路复用I/O（multiplexing I/O）
多路复用的特点是通过一种机制一个进程能同时等待多个IO文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。
对于监视的方式，又可以分为 select， poll， epoll三种方式。

I/O多路复用的最大优势是系统开销小

第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。
第二个阶段都是阻塞的
***** select
内核级别的调用，能等待多个socket，并能同时实现对多个 IO 端口的监听。

当其中任何一个 socket 准备好了，就能返回进行可读，然后进程进行 recvform 系统调用，
将数据由内核拷贝到用户进程，当然这个过程是阻塞的。
***** poll
poll的实现和select非常相似，只是描述fd集合的方式不同，
***** epoll
+ epoll既然是对select和poll的改进
+ 而epoll提供了三个函数:
  + epoll_create是创建一个epoll句柄；
  + epoll_ctl是注册要监听的事件类型；
  + epoll_wait则是等待事件的产生。
**** 信号驱动式I/O（signal-driven I/O）
首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据
*** 异步I/O（asynchronous I/O）
相对于同步IO，异步IO不是顺序执行。
用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。
等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。
IO两个阶段，进程都是非阻塞的。

信号驱动I/O是由内核通知我们如何启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。
** https
https 除了 TCP 的三个包之外，还需要 ssl 握手的9个包(非对称 and 签名，对称)

安全，但会导致建立连接的速度变慢，而且增加服务器资源的消耗。
** TCP 三次握手
*** 原因
 网络存在延迟，建立连接的数据报发到服务端时可能间隔时间过长，
 此时客户端已无建立连接的请求。
*** 具体过程
+ client -> server: SYN=1,seq=client_isn
+ server -> client: SYN=1,seq=server_isn,ack=client_isn+1
+ client -> server: SYN=0,seq=client_isn+1,ack=server_isn+1

(ack确认号，数字表示期望接受的下一个序列)
** TCP 四次挥手
*** 具体过程
+ client shutdown
+ client -> server: FIN
+ server -> client: ACK
+ client 依据ACK补发数据包，当ACK为FIN的时，进入FIN_WAIT2状态。
+ server 在发送FIN的ACK之后进入 CLOSE_WAIT 状态，结合app需求继续发送数据包。
+ server shutdown
+ server -> client: FIN，并进入 LAST_ACK 状态。
+ client -> server: ACK
+ server 收到的ACK不对，则补发之前的包
+ 当 client 回复 FIN 的 ACK 后，进入 TIME_WAIT 状态。
*** CLOSE_WAIT
在CLOSE_WAIT状态下，被动方还有数据需要传送。（被动方）

太多CLOSE_WAIT暗示了，被动方的应用程序没有合适地关闭socket。
*** TIME_WAIT
**** 有效的实现TCP全双工连接的终止
等待被关闭方应答ACK的确认。
如果主动关闭方最后的 ACK 丢失，那么最后关闭方将重发 FIN 。
**** 允许老的重复包在网络中消逝
防止新建立的连接收到旧的包，从而引起混乱。
**** time_wait状态在socket下需要等待两倍的MSL
MSL是一个数据在网络中单向发出到确认丢失的时间，
一个数据报可能在发送途中丢失，也可能在其响应过程中成为残余数据报。

总时间有两部分组成：ACK到达server时失效的情况（1msl)，加上重发FIN的时间(1msl)。
** TCP 重传
*** 目的
报文重传是 TCP 最基本的错误恢复功能，它的目的是防止报文丢失。
*** 重传时间的设置
+ 重传时间过短：在网络因为拥塞引起丢包时，频繁的重传会进一步加剧网络拥塞。
+ 重传时间过长：接收方长时间无法完成数据接收，引起长时间占用连接链路，消耗资源。
*** 重传计数器
重传计数器的主要功能是维护重传超时值(RTO)。
当报文使用 TCP 传输时，启动重传计时器，
除非收到 ACK 或者重传值达到上限，
当超时时，RTO 翻倍，并启动重传。
*** 超时重传
*** 快速重传
接收方发现有数据包丢失时，就会发送重复 ACK 报文来告诉发送端重传丢失的报文。
** TCP 流量控制
+ 管理两端的流量，以免会产生发送过快导致溢出，或处理过快而浪费时间的状态。
+ 主要采用滑动窗口进行流量控制。
+ 滑动窗口表示的是接收方能接收数据的大小。(缓冲区的剩余大小）
+ 对于TCP会话的发送方，“已经发送但还未收到对端ACK的”和“未发送但对端允许发送的”这两部分数据称之为发送窗口。
+ 比特滑动窗口协议，回退n协议，选择重传协议
** TCP 拥塞控制
*** 目的
避免过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。
*** 算法
**** 慢启动
拥塞窗口是慢速启动的，但是按指数规则增长。直到到达一个阈值。
**** 拥塞避免:加法增加
为了在慢速发生之前避免拥塞，必须降低指数增长的速度。
其通过加法增加拥塞窗口。
**** 拥塞发生：乘性减少
重传的发生存在两种情况:

1)如果 RTO 超时，那么存在非常严重的拥塞的可能性；包可能已在网络中丢失。
在这种情况下，TCP 做出强烈的反应：
+ 设置阈值为 cwnd 的一半
+ 重新设置 cwnd 为1
+ 启动慢速启动阶段

2)如果收到3个相同的 ACK，那么存在着轻度拥塞的情况。此时做出快速重传的同时，执行下面的步骤
+ 设置阈值为 cwnd 的一半
+ 设置 cwnd 为阈值 + 3MSS
+ 启动快速恢复阶段
**** 快速恢复
当收到3个重复的 ACK 之后，TCP 之后进入快速恢复阶段。

快速恢复状态是一种介于慢启动和拥塞避免之间的状态。
在这个阶段可能发生三种事件：
+ 重复 ACK 继续到达，那么 TCP 保持这种状态，但是 cwnd 呈指数增长。
+ 如果发生超时， TCP 假设网络中有真实的拥塞，并进入慢启动状态。
+ 如果一个新的 ACK 到达，TCP 进入拥塞避免状态。但是 cwnd 大小减少到阈值。
** 如何让 UDP 实现可靠传输
+ UDP 不属于连接型协议，具有资源消耗小，处理速度快的优点。
+ 在应用层实现确认机制、重传机制、窗口确认机制。
+ 如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：
  + 发送：包的分片、包确认、包的重发
  + 接收：包的调序、包的序号确认
** HTTP 长连接短连接
*** 短连接
 连接->传输数据->关闭连接 
*** 长连接
连接->传输数据->保持连接 -> 传输数据-> ...........->直到一方关闭连接，多是客户端关闭连接。 

长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。
*** HTTP的特点
HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。
也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。
HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。

+ HTTP1.1，增加了持久连接支持(貌似最新的HTTP1.1 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。
+ 从 HTTP 1.1 开始，默认支持长连接，其 keep-alive不会永久保持连接，其有一个保持时间。
*** 什么时候用长连接，短连接
+ 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。
+ 实现长连接要客户端和服务端都支持长连接。
+ 并发量大，但每个用户无需频繁操作情况下需用短连好。比如 web 网站的 http 服务。
*** 长短连接的比较
+ 长连接可以省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间。
+ 不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测 TCP 连接的存活。
+ 短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。
+ 但如果客户请求频繁，将在 TCP 的建立和关闭操作上浪费时间和带宽
** Cookie 和 Session
*** Session
+ HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，使用 Session 机制来识别具体的用户。
+ 保存在服务端，有一个唯一的标识。
+ Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中
+ session 的运行依赖 session id，其是存在 cookie 中的，如果浏览器禁用了 cookie，需要通过其他方法实现，比如在 url 中传递 session_id。
*** Cookie
+ 实现 Session 跟踪特定用户的方法。
+ Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
** HTTP 请求响应报文格式
*** HTTP 请求报文
一个 HTTP 请求报文由：请求行，请求头部，空行和请求数据四个部分组成。
**** 请求行
+ 请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔
+ 例如：GET /index.html HTTP/1.1
+ HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT
***** GET
+ 最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。
+ GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。
***** POST
+ POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中
***** HEAD
+ HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。
+ 当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。
***** GET 和 POST 的区别
+ GET提交，请求的数据会附在URL之后，以?分割URL和传输数据，多个参数用&连接; POST提交：把提交的数据放置在是HTTP包的包体。
+ HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。但是GET:特定浏览器和服务器对URL长度有限制。
+ POST的安全性要比GET的安全性高;通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录
**** 请求头部
+ 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。
+ 请求头部通知服务器有关于客户端请求的信息
+ 典型的请求头部有：User-Agent，Accept，Host。
**** 空行
最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。
**** 请求数据
请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。
*** HTTP 响应报文
HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行，响应正文。
**** 状态行
HTTP-Version Status-Code Reason-Phrase CRLF
+ HTTP-Version表示服务器HTTP协议的版本；
+ Status-Code表示服务器发回的响应状态代码；
+ Reason-Phrase表示状态代码的文本描述
**** 消息报头
+ key:value 形式
+ 表示响应的相关信息
** HTTP 常见状态码
*** 1开头
+ 1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码
*** 2开头
+ 2xx (成功)表示成功处理了请求的状态代码
+ 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
+ 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。
+ 206 (部分内容) 服务器成功处理了部分 GET 请求(客户端进行了范围请求)。 
*** 3开头
+ 3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
+ 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。
+ 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
+ 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。(包含的其他文件），对于 POST 请求，它表示请求已经被处理，可以使用 GET 方法继续访问资源。
+ 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
+ 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。对于 POST 请求，表示还没处理好，需要对新的 URI 重新发送POST请求。
+ 303 和 307 的存在，归根结底是由于 POST 方法的非幂等属性引起的。
*** 4开头
+ 4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理。
+ 400 (错误请求) 服务器不理解请求的语法。
+ 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
+ 403 (禁止) 服务器拒绝请求。
+ 404 (未找到) 服务器找不到请求的网页。
*** 5开头
+ 5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。
+ 500 (服务器内部错误) 服务器遇到错误，无法完成请求。
+ 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。
** 子网掩码
+ 未做子网划分的 IP 地址：网络号＋主机号
+ 做子网划分后的 IP 地址：网络号＋子网号＋子网主机号 
+ 192.168.1.x 子网掩码 255.255.255.0
+ 192.168.1.x/24（*nix表示法）意思一致。
** 当你在浏览器中输入一个 url 后发生了什么
*** 解析URL
浏览器会首先判断地址栏中输入的是 URL 还是搜索的关键字，
如果输入的协议或主机名不合法时，浏览器就会把文字传递给搜索引擎。
*** 检查 HSTS 列表
+ 浏览器检查自带的“预加载HSTS(HTTP严格传输安全)”列表，这个列表中包含了那些请求浏览器只使用 HTTPS 进行连接的网站。
+ 如果网站在这个列表里，浏览器就会使用 HTTPS 而不是 HTTP 协议。
+ 注意，如果一个网站不在 HSTS 列表里，也可以要求浏览器使用 HSTS 政策进行访问，这个发生在第一个 HTTP 请求之后，不过会遭到降级攻击。
*** 转换非ASCII的Unicode字符
+ 浏览器检查输入是否含有不是 a-z, A-Z,0-9,-或者.的字符。
+ 如果含有非ASCII字符，则采用Punycode编码。
*** DNS 查询
+ 浏览器检查域名是否在缓存中
+ 如果缓存中没有，就去调用 gethostbyname 库函数。
+ 如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它就会向DNS服务器发送一条DNS查询请求。DNS路由器是由网络通信栈提供的，通常是本地路由器或者ISP的缓存DNS服务器。
+ 如果 DNS 服务器和我们的主机在同一个子网内，系统会发送 DNS 查询到 DNS 服务器。
+ 如果 DNS 服务器和我们的主机在不同的子网，系统会发送 DNS 查询到默认网关。
*** ARP
要从链路层在子网内发送数据包，除了需要知道目标IP地址之外，还需要知道目标的MAC地址。
+ 首先查询ARP缓存，如果命中，则返回结果
+ 如果没有
  + 查看路由表，看看目标IP地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。
  + 查询连接的网络接口的MAC地址
  + 发送ARP请求

根据连接主机和路由器的硬件类型的不同，可以分为以下几种情况：
+ 直连：如果我们和路由器是直接连接的，路由器会返回一个ARP Reply。
+ 集线器：如果我们连接一个集线器，集线器会把ARP请求向所有其它端口广播。
+ 交换机：交换机会检查本地 MAC表，看看哪个端口有我们要找的那个MAC地址，如果都没有，则向其他端口广播这个ARP请求。

现在我们有了DNS服务器或者默认网关的IP地址和MAC地址，我们可以继续DNS请求了：
+ 使用53端口向DNS服务器发送UDP请求包，如果包太大，则使用TCP
+ 如果本地ISP 或DNS服务器没有找到结果，它会发送一个递归查询请求给高层DNS服务器。
+ 对于网关路由器，其通过IP层的路由算法将封包转发到下一个路由。
*** 使用套接字
当浏览器得到了目标服务器的IP地址，以及URL中给出来的端口号(http是80，https是443)，调用系统socket，创建一个TCP套接字。
+ 在传输层，目标端口会被加入头部，源端口会在系统内核中动态选取。
+ 在网络层，添加了IP头部，其中包含了目标服务器的IP地址以及本机的IP地址。
+ 在链路层，添加了frame头部，包含了本地和目标MAC。
*** 建立连接
**** TCP三次握手
**** TLS握手
*** HTTP
*** 浏览器显示
* 数据库
** 数据库范式
*** 范式
一张数据表的表结构所符合的某种设计标准的级别。
*** 第一范式(1NF)
符合1NF的关系中的每个属性都不可再分

1NF是所有关系型数据库的最基本的要求
*** 第二范式(2NF)
在1NF的基础上消除了非主属性对码的部分函数依赖
**** 函数依赖
若在一张表中，在属性(或属性组)X的值确定的情况下，必定能确定属性Y的值，记X->Y。
***** 完全函数依赖
对于X的任何一个真子集X'，不存在X'->Y
***** 部分函数依赖
非完全函数依赖
***** 传递函数依赖
若Y->Z，且X->Y，那么我们称Z传递函数依赖于X。
**** 码
对于属性(或属性组)K，若除K之外的所有属性都完全依赖于K，那么我们称K为候选码。
**** 主属性
包含在任意一个码中的属性
*** 第三范式(3NF)
3NF在2NF的基础上，消除了非主属性对于码的传递函数的依赖。
*** BCNF 范式
在3NF的基础上消除了主属性对于码的部分与传递函数的依赖。

(主属性/码 过多)
** 数据库指令
schema 是对一个数据库的结构性描述。
其在一个关系型数据库中，定义了表，每个表的字段，还有表和字段之间的关系。
*** DDL(Data Definition Language)
数据定义语言：被用来定义数据框架和 schema，立即提交
+ CREATE
+ ALTER
+ DROP-删除整个表
+ TRUNCATE-清空表中数据
+ COMMENT
+ RENAME
*** DML(Data Manipulation Language)
数据操作语言：用来管理 schema 中对象的语言
+ SELECT
+ INSERT
+ UPDATE
+ DELETE-删除一个表中的数据，一般用于删除特定行
+ MERGE-insert or update
+ CALL-调用一个PL/SQL或者Java子程序
+ EXPLAIN PLAN
+ LOCK TABLE
*** DCL(Data Control Language)
+ GRANT-授予用户访问数据库的权限
+ REVOKE-收回权限
*** TCL(Transaction Control Language)
事务控制语言用来管理数据操作语言带来的变动。
它允许语句以逻辑事务的形式进行组合。
+ COMMIT
+ SAVEPOINT：使用保留点
+ ROLLBACK
+ SET TRANSACTION:改变事务选项（隔离等级，回退段）
** 数据库隔离等级
*** 未提交读(Read uncommitted)
+ 一个事务可以读到另一个事务未提交的数据
+ 事务在读数据的时候未加锁
+ 事务在修改数据的时候只对数据增加行级共享锁
+ 未提交读会导致脏读(事务1对某个值进行修改，然后事务2读取该值，此后事务1由于某种原因撤销了对该值的修改，导致事务2读取的值无效)
*** 提交读(Read committed)
+ 在一个事务修改数据过程中，如果事务还没提交，其他事务不能读取该数据
+ 事务对当前读取的数据加行级共享锁，一旦读完该行，立即释放该行级共享锁
+ 在事务1读取完改行数据后，事务2才能对该行数据进行修改
+ 事务1在更新某行数据时，事务2不能对这行数据进行更新，直到事务1结束
+ 避免了脏读的现象
+ 但会导致不可重复读(在一个事务范围内两个相同的数据返回不同数据)
*** 可重复读(Repeatable reads)
+ 事务在读取某数据的瞬间，必须对其加行级共享锁，直到事务结束才释放
+ 事务在更新某数据的瞬间，必须对其加行级排他锁，直到事务结束才释放
+ 避免了不可重复读现象
+ 但还是会产生幻读(当事务没有获取范围锁的情况下，执行SELECT ... WHERE操作)
*** 可序列化
+ 事务读取数据时，必须对其加表级共享锁，直到事务结束才释放
+ 事务在更新数据时，必须对其加表级排他锁，直到事务结束才释放
** 关系型与非关系型数据库
*** 关系型数据库
+ 采用了关系模型来组织数据的数据库
+ 二维表格模型，由二维表及其之间的联系所组成的一个数据组织
**** 优点
+ 易于维护
+ 复杂查询
+ 事务支持
**** 瓶颈
+ 高并发读写需求
+ 海量数据的高效率读写
+ 高扩展性和可用性

对于web来说，关系数据库的很多特性不再需要：
+ 事务一致性
+ 读写实时性
+ 负责SQL,特别是多表关联查询
*** 非关系型数据库
+ 非关系型的，分布式的，且一般不保证遵循ACID原则的数据存储系统
+ 其严格上不是一种数据库，而是一种数据结构化存储方法的集合
+ 结构不固定，扩展性好
+ 存储方式多种多样
**** 分类
+ 面向高性能并发读写的key-value数据库: Redis, Tokyo Cabinet, Flare
+ 面向海量数据访问的面向文档数据库: MongoDB, CouchDB
+ 面向可扩展性的分布式数据库
**** NoSQL 选型
+ 数据结构特点
+ 写入特点
+ 查询特点
** 什么是存储过程
*** 存储过程与函数
+ 存储过程是一些预编译的SQL语句，涉及特定表及其他任务，用户可以执行存储过程，其存储在数据库中。
+ 函数是数据库已定义的方法，它接收参数并且返回某种类型的值，并且不涉及特定用户表。
*** 存储过程的特点
+ 存储过程是一个预编译的代码块，执行效率高。
+ 一个存储过程替代大量的SQL语句，可以降低网络通信量。
+ 其更加安全
+ 虽然使用存储过程能在网络开销、安全性、性能上获得很多好处，但在数据库迁移时却会产生麻烦
** 数据库优化
*** 指导思路
+ 首先保证写出的SQL都是优化器喜欢的
+ 寻找性能瓶颈：io 内存 CPU 网络 锁
*** 具体措施
+ 优化SQL语句：开启慢查询，寻找有问题的SQL语句，通过explain查询分析SQL的执行计划；针对limit,groupby优化
+ 索引优化：选择合适的列建立索引；维护索引，去掉重复索引
+ 数据库结构优化：选择合适的数据类型，范式和反范式的权衡，垂直切分和水平切分，选择合适的存储引擎
+ 系统配置和硬件优化
** 索引及其优缺点
索引是对数据库表中一或多个列的值进行排序的结构，是帮助 MySQL 高效获取数据的结构。
*** 索引类型
+ 普通索引
+ 唯一索引
+ 主键索引
+ 全文索引
*** 索引的优缺点
+ 索引加快数据库的检索速度
+ 索引降低了插入、删除、修改等维护任务的速度
+ 唯一索引可以确保每一行数据的唯一性
+ 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
+ 索引需要占物理和数据空间
*** 使用索引查询一定能提高查询的性能吗？
通常，通过索引查询数据比全表扫描要快，但是我们也必须注意到它的代价。

索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，
索引本身也会被修改。这意味着条记录的 INSERT, DELETE, UPDATE将为此多付出4,5次的磁盘 I/O。
因为索引需要额外的存储空间和处理，那些不必要的索引反而会似的查询反应时间变慢。
*** 索引范围查询
+ 基于一个范围的检索，一般查询返回结果集小于表中记录数的30%
+ 基于非唯一性索引的检索
*** 聚集索引和非聚集索引
聚集索引的顺序是数据的物理存储顺序，而对非聚集索引的顺序与数据物理排列顺序无关。
因此，一个表最多只能有一个聚集索引。

聚集索引对于那些经常要搜索范围值的列特别有效。
使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。
对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集(物理排序)。

在非聚集索引中，数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。
索引中的项目按索引键值的顺序存储，而表中的信息按另一种顺序存储。
** B+树和B树
*** 区别
+ B+ 树可以被看作每个非叶结点之允许包含键而不允许包含值的B树
+ 并且 B+ 树的数据及其对应的键值均以链表形式被存储在底层的叶结点上
*** B+ 树优势
+ 因为内部结点上不包含数据，一页内存上可以存放更多的键，因此可以提高缓存命中
+ 叶结点是使用链表数据结构的，全表扫描可以通过一个线性扫描完成，而B树需要缓存命中低的树形扫描
*** B 树优势
+ 因为B树的每个键都可以存储数据，经常使用的结点可以靠近根结点来提高数据存储速度
** 事务
事务是并发控制的基本单位。
它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。
事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。
*** ACID
**** Atomic 原子性
事务中包含的操作被看作是一个逻辑单位，其要么全部成功，要么全部失败。
**** Consistency 一致性
只有合法的数据可以被写入数据库，否则事务回滚到最初状态。
**** Isolation 隔离性
事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。
同时，并行事务的修改必须能与其他并行事务的修改相互独立。
**** Durability 持久性
事务结束后，事务处理的结果必须能够得到固化。
** 乐观锁和悲观锁
*** 乐观锁
+ 假定不会发生并发冲突，只在提交操作时检查是否违反数据完整性。
+ 如果产生冲突的话，正在提交的事务会进行回滚。
+ 在实际中可使用版本号实现乐观锁。
+ 场景：发生冲突的概率比较低。
*** 悲观锁
+ 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。
+ 悲观锁适用于可靠的持续性连接，诸如C/S应用。对于Web应用的HTTP连接，并不适用。
+ 锁的使用意味着性能的损耗，在高并发、锁定持续时间长的情况下，尤其严重。
+ 非正常中止情况下的解锁机制，设计和实现较为麻烦。
+ 流程：
  + 对任意记录进行修改前，先尝试对记录加上排他锁。
  + 如果加锁失败，则等待或者抛出异常。
  + 如果加锁成功，则可对记录修改，完成后解锁。
+ MySQL InnoDB:
  + set autocommit=0;
  + begin;/begin work;/start transaction;
  + select ... from ... for update;
  + commit;/commit work;
** 游标
在检索出来的行中，前进或后退一行或多行。

通过判断全局变量@@FETCH_STATUS可以判断其是否到了最后。
通常此变量不等于0表示出错或到了最后。
** 触发器
+ 触发器是特殊的存储过程，它在特殊的数据库活动发生时自动执行。
+ 约束的处理比触发器更快。
+ 事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。
+ 语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。
** SQL注入式攻击
*** 定义
 攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串中，欺骗服务器执行恶意的SQL命令。
 在某些表单中，用户的输入内容直接用来构造动态SQL命令，或作为存储过程的输入参数，这类表单特别容易受到SQL注入攻击。

*** 防范措施
+ 替换单引号
+ 删除用户输入中的所有连字符
+ 限制执行查询的数据库账户权限
+ 用存储过程来执行查询
+ 检查用户输入的合法性
+ 将用户信息加密保存
+ 检查提取数据的查询所返回的记录数量
** drop、delete和truncate
+ delete和truncate只删除表的数据不删除表的结构
+ 速度：drop>truncate>delete
+ delete是dml，而truncate和drop是ddl。
+ 不再需要一张表时，使用drop
+ 想删除部分行时用delete
+ 保留表而删除所有数据时用truncate
** 超键，候选键，主键，外键
+ 超键：在关系中能唯一识别元组的属性集。
+ 候选键：最小超键，没有冗余元素的超键。
+ 主键：一个表只能有一个主键，且不能为空值。
+ 外键：在一个表中存在的另一个表的主键。
** 视图
视图是一种虚拟的表，其包含的是使用时动态数据的检索。
视图通常是有一个表或者多个表的行或列的子集。
可以对视图进行增，改，查等操作。(不同的DBMS，要求不同)
** InnoDB和MyISAM
*** MyISAM
 MyISAM 是 MySQL5.5之前版本的默认数据库引擎，虽然性能极佳，但却不支持事物处理。
*** InnoDB
**** 特点
 + 支持ACID
 + 支持行锁，以及类似ORACLE的一致性读，多用户并发
 + 支持非锁定读(默认情况下读取不会产生锁)
 + 独有的聚集索引主键设计方式，可大幅提升并发读写性能
 + 支持外键
 + 支持崩溃数据自修复
**** 关键特性
+ 对非聚集索引的插入缓存(以一定频率合并缓存和索引)
+ 两次写来解决部分写失败问题(内存中的2M的分两次 doublewrite buffer -> 共享空间的物理磁盘 -> 同步磁盘)
+ 自适应哈希索引(引擎监控发现建立hash时可以提高性能，则建立)
**** MVCC 特性
+ 对于事务型的存储引擎，仅仅依赖锁是不够的，还需要 MVCC(Multiversion Concurrency Control)的帮助。
+ 通过 MVCC 来保存旧版本的修改信息来实现事务的并发控制和回滚。
+ 其在表中增加了两个隐藏列：1.insert或update的版本；2.delete的版本。
+ 对于更新，创建列为当前SVN，同时删除列为update之前的创建列的 SVN 值。
*** 区别
**** 存储结构
+ MyISAM:每个在磁盘上存储三个文件。存储表定义(.frm)，数据文件(.MYD)，索引文件(.MYI)。
+ InnoDB:所有表存储在同一个数据文件中，InnoDB 表的大小只受限于操作系统。
**** 存储空间
+ MyISAM: 可被压缩，存储空间较小。支持三种不同的存储格式：静态表，动态表，压缩表。
+ InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
**** 可移植性，备份及恢复
+ MyISAM：数据以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。
+ InnoDB：在数据量达到几十G的时候就相对痛苦了。
**** 事务支持
+ MyISAM：强调的是性能，每次查询具有原子性，其执行速度比 InnoDB 类型更快，但不提供事物支持。
+ InnoDB：强调事物支持，外部键等高级数据库功能。具有事物，回滚和崩溃修复功能的事物安全型表。
**** AUTO_INCREMENT
+ MyISAM：引擎的自动增长必须是索引，如果是组合索引，自动增长可以不是第一列，可以根据前面几列进行排序后递增。
+ InnoDB：引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。
**** 表锁差异
+ MyISAM：只支持表级锁，用户在操作MyISAM表时，select,update,delete,insert语句都会给表自动加锁。
+ InnoDB：支持事物和行级锁，是 InnoDB 的最大特色。行锁大幅度提高了多用户并发操作的性能，但是 InnoDB 的行级锁只在 WHERE 的主键是有效的，非主键的 WHERE 都会锁全表。
**** 全文索引
+ MyISAM：支持 FULLTEXT 类型的全文索引
+ InnoDB：不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引。
**** 表主键
+ MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。
+ InnoDB：(聚簇索引)如果没有设定主键或非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。
**** 表的具体行数
+ MyISAM：保存有表的总行数。
+ InnoDB：没有保存有表的总行数。
**** CURD 操作
+ MyISAM：如果执行大量的 SELECT，MyISAM 是最好的选择。
+ InnoDB：如果你的数据执行大量的 INSERT 或 UPDATE，出于性能方面的考虑，应该使用 InnoDB 表。DELETE(一行行删除) 从性能上 InnoDB 更优，在 InnoDB 上如果要清空大量数据的表，最好使用 truncate table 命令。
**** 外键
+ MyISAM：不支持
+ InnoDB：支持
*** 存储引擎选择的基本原则
**** MyISAM
+ R/W > 100:1 且 update 相对较少
+ 并发不高
+ 表数据量小
+ 硬件资源有限
**** InnoDB
+ R/W 较小，频繁更新大字段
+ 表数据量超过1000万，并发高
+ 安全性和可用性要求高
**** Memory
+ 有足够的内存
+ 对数据一致性要求不高
+ 需要定期存档数据
** 分库分表
*** 垂直分表
+ 也称为“大表拆小表”，拆分是基于关系型数据库中的“列”字段进行的
+ 通常情况下，将一些不常用或者长度较大的字段拆分出去放到“扩展表”中
+ 拆分会便于开发和维护
+ 某种意义上也能避免“跨页”问题，防止产生额外的开销
+ 需要改写以前的查询语句，会带来一定的成本和风险
*** 垂直分库
+ 按照业务模块来划分出不同的数据库
+ 系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护
+ 数据库往往容易成为应用系统的瓶颈
+ 在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈
+ 但不好的拆分会带来跨库join、分布式事物等
**** 垂直分库的问题及解决
***** 跨库join的问题
一般应禁止跨库join，遇到这种问题应优先调整架构
***** 解决思路
+ 全局表-每个库中保存一份，这类数据很少发生修改
+ 字段冗余
+ 关联数据同步
+ 系统层组装数据
*** 水平分表
+ 也称横向分表，将表中不同的数据行按照一定规律分布到不同的数据库表中
+ 可以降低单表数据量，优化查询性能
+ 但本质上这些表还是存放在一个库中，依旧会产生IO瓶颈
+ 最常见的方式是采用主键或者时间等字段进行Hash和取模后拆分
*** 水平分库分表
+ 将拆分出来的行分出来保存在不同的数据库中
+ 有些系统中使用的“冷热数据分离”
+ 能够有效缓解单机和但库的性能瓶颈和压力，突破IO，连接数，硬件资源等的瓶颈
+ 但同时，也会带来跨分片的复杂查询，跨分片事务等问题
* 算法与数据结构
** 红黑树
*** 红黑性质
+ 每个结点非红即黑
+ 根结点为黑
+ 每个叶子(NIL)为黑
+ 如果一个结点为红，它的两个子结点均为黑
+ 对于每个结点，所有从该结点到其后代叶子的简单路径均含有相同数量的黑色结点
*** 红黑树的特点
+ 一个含有 n 个内部结点的红黑树，其高度最多为2lg(n+1)
*** 旋转
* 设计模式
** 最常用
+ 工厂模式
+ 代理模式
+ 适配器模式
+ 模板方法模式
+ 门面模式
+ 桥梁模式
+ 单例模式
+ 装饰模式
** 创建型模式
*** 抽象工厂
提供一个创建一系列相关或相互依赖对象的接口，无需指定它们具体的类。

抽象工厂的优缺点：
+ 分离了具体的类
+ 使得易于交换产品系列
+ 有利于产品的一致性
+ 难以支持新种类的产品
*** 生成器
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

其由两部分组成：
+ Builder：为创建一个Product对象的各个部件指定抽象接口。
+ Director：构造一个使用Builder接口的对象。

Build模式的效果：
+ 它使得你可以改变一个产品的内部表示
+ 它将构造代码和表示代码分开
+ 它使你可对构造过程进行更精细的控制
*** 工厂方法
*** 原型
*** 单件
**** 单价模式的几种写法
***** 懒汉式
#+BEGIN_SRC java
  public class Singleton{
      private Singleton static instance;
      private Singleton(){}
      public static synchronized Singleton getInstance() {
          if (instance == null) {
              instance = new Singleton();
          }
          return instance;
      }
  }
#+END_SRC
***** 双重检验锁
#+BEGIN_SRC java
  public class Singleton {
      private volatile static Singleton instance; //声明成 volatile
      private Singleton (){}
      public static Singleton getSingleton() {
          if (instance == null) {                         
              synchronized (Singleton.class) {
                  if (instance == null) {       
                      instance = new Singleton();
                  }
              }
          }
          return instance;
      }
  }
#+END_SRC

这里 instance 必须声明为 volatile 来形成内存屏障，阻止指令重排序。
对于语句 instance = new Singleton()。JVM 大概做三件事：
#+BEGIN_EXAMPLE
  1.给instance 分配内存
  2.调用 Singleton 的构造函数来初始化成员变量
  3.将 instance 对象指向分配的内存空间
#+END_EXAMPLE

经过 JVM 的即时编译器的指令重排序优化之后，最终的执行顺序可能为1-3-2。
此时当3执行完而2未执行时，被另一线程抢占，这时 instance 已经是非 null 了，产生错误。
***** 饿汉式
#+BEGIN_SRC java
  public class Singleton() {
      private static final instance = new Singleton();
      private Singleton() {}
      public static Singleton getInstance(){
          return instance;
      }
  }
#+END_SRC
***** 静态内部类
#+BEGIN_SRC java
  public class Singleton() {
      private Singleton(){}
      private static class SingletonHolder{
          private static final Singleton INSTANCE = new Singleton();
      }
      public static Singleton getInstance(){
          return SingletonHolder.INSTANCE;
      }
  }
#+END_SRC

***** 枚举 Enum
#+BEGIN_SRC java
  public enum Singleton{
      INSTANCE;
  }
#+END_SRC
**** Java单价模式和Spring单件模式的区别
+ Java单件模式的作用域由类加载器所控制，其要求在给定类加载器中只能有一个实例
+ 而Spring的则由容器上下文所管理，其要求不能在给定容器上下文中创建多于一个类实例
** 结构型模式
*** 适配器模式
将一个类的接口转换为客户希望的另一个接口。
Adapter模式使得原本接口不兼容而不能一起工作的那些类可以一起工作了。

有时，为复用而设计的工具箱类不能被复用的原因仅仅是因为它的接口与专业应用领域的接口不匹配。
*** 桥接模式
将抽象部分与它们的实现部分分离，使它们都可以独立变化。

继承机制将抽象部分与它们的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。

把平台实现提取出抽象层，隔离封装。
*** 组合模式
将对象组合成树形结构以表示“部分-整体”的层次结构。
Composite 使得用户对单个对象和组合对象的使用具有一致性。

Composite 模式的关键是一个抽象类，它既可以代表图元，又可以代表图元的容器。
*** 装饰模式
动态地给一个对象增加一些额外的职责。
就增加功能来说，Decorator 模式相比生成子类更加灵活。
*** 外观模式
为子系统的一组借口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

将一个系统划分为若干个子系统有利于降低系统的复杂性。
引入外观模式可以给子系统提供一个单一而简单的界面。
*** 享元模式
运用共享技术有效地支持大量细粒度的对象。(类似 constant pool)

有些应用程序得益于在整个设计过程中采用对象技术，但简单化的实现代价极大。

flyweight 共享对象：
+ 内部状态：存储于 flyweight 中，它包含独立于 flyweight 场景的信息，能够被共享。
+ 外部状态：取决于 flyweight 场景，并根据场景而变化，因此不能共享。(使用特殊的数据结构来进行表示)

适用场景：
+ 一个应用程序中使用了大量的对象
+ 完全由于使用大量的对象，造成很大的存储开销
+ 对象的大多数状态都变为外部状态
+ 如果删除对象的外部状态，那么可以用相对较少的共享对象来取代很多组对象
+ 应用程序不依赖于对象标识。
*** 代理模式
为其他对象提供一种代理以控制对这个对象的访问。

常见使用场景：
+ 远程代理：为了一个对象在不同的地址空间提供局部代理
+ 虚代理：根据需要创建开销大的对象
+ 保护代理：控制对原始对象的访问
+ 智能指引：取代了简单的指针，它在访问对象时执行一些附加操作。
** 行为型模式
* Linux 命令
** ldd 查看程序依赖库
作用：用来查看程式所需的共享库，常用来解决程式因缺少某个库文件而不能运行的一些问题。
** lsof 一切皆文件
lsof(list open files)是一个查看当前系统文件的工具。
在 linux 环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。
如传输控制协议(TCP)和用户数据报协议(UDP)套接字等，系统在后台都为该应用程序分配一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。
** ps 进程查看器
Process Status。用来列出系统中当前运行的那些进程。
ps 命令列出的是当前那些进程的快照，就是执行 ps 命令的那个时刻的那些进程，
如果想要动态的现实进程信息，就可以使用 top 命令。
** pstack 跟踪进程栈
此命令可显示每个进程的栈跟踪。
pstack 命令必须由相应进程的属主或 root 运行。
可以使用 pstack 来确定进程挂起的位置。
此命令唯一选项是要检查的进程的 PID。
** strace 跟踪进程中的系统调用
strace 常用来跟踪进程执行时的系统调用和所接收的信号。
其可以跟踪到一个进程产生的系统调用，包括参数，返回值，执行消耗的时间。
** ipcs 查询进程间的通信
ipcs 是 linux 下显示进程见通信设施状态的工具。可以显示消息队列，共享内存和信号量的信息。
** top linux 下的任务管理器
top 命令是 Linux 下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况。
** free 查询可用内存
** vmstat 监视内存使用情况
Virtual Memory Statistics。可实时动态监视操作系统的虚拟内存、进程、CPU活动。
** iostat 监视 I/O 子系统
I/O statistics。用来动态监视系统的磁盘操作活动。
** sar 找出系统瓶颈的利器
System Activity Reporter 系统活动情况报告。
sar 工具将对系统当前的状态进行取样，然后通过计算数据和对象来表达系统的当前运行状态。
其所需的负载很小。

从下面方面对系统的活动进行报告：
+ 文件的读写情况
+ 系统调用的使用情况
+ 串口
+ CPU效率
+ 内存使用状况
+ 进程活动
+ IPC有关活动
** readelf elf文件格式分析
这个工具和 objdump 命令提供的功能类似，但是它显示的信息更为具体，
并且它不依赖BFD库。

ELF(Executable and Linking Format)是一种对象文件的格式，
用于定义不同类型的对象文件都放了什么。
** objdump 二进制文件分析
objdump 工具用来显示二进制文件的信息。
** nm 目标文件格式分析
nm 命令显示关于指定 File 中符号的信息，文件可以是对象文件、可执行文件或对象文件库。
** size 查看程序内存映像大小
查看程序被映射到内存中的映像所占用的大小信息。
** wget 文件下载
Linux 系统中的 wget 是一个下载文件的工具，它用在命令行下。
其支持 HTTP,HTTPS和FTP协议，可以使用HTTP代理。

特点：
+ 稳定
+ 递归下载
+ 断点续传
** scp 跨机远程拷贝
secure copy。用于 Linux 下进行远程拷贝文件的命令。
** crontab 定时任务
时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。
这个命令适合周期性的日志分析或数据备份。
* 面试
** 应聘者提问
提与招聘职位或项目相关的问题。
