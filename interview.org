* Java
** Java NIO
*** 目的
使用高速 IO 而无需编写自定义的本机代码。
将最耗时间的 IO 操作(提取和转移缓冲区)转移回操作系统。
*** 与传统 IO 的比较
一个是面向块的，一个是面向流的。
+ 传统 IO：简单优雅，但速度慢
*** 核心对象
**** 通道与缓冲区
***** 通道(channel)：对原 IO 包的流的模拟。
***** 缓冲区(buffer)：
 + Position:当前位置
 + Limit:最大可读/写的位置
 + Capacity:
**** 非阻塞 IO
Java NIO 可以让你非阻塞地使用 IO
**** 选择器
+ 单个线程可以监听多个通信信道的事件
+ 注册 IO 事件的地方
*** 应用场景
+ 高性能，高容量服务端应用程序
+ 网络协议的解析，TCP 拆包，粘包
+ 远程过程调用 RPC
+ C10K 问题:在有1万个同时连接时，传统的阻塞的，每个连接一个线程的网络处理方式存在的问题
*** non-blocking
如果要启用non-blocking模式的 IO 操作，
可以很方便的通过 configureBlocking 来设置。
*** IO 多路复用模式
一般来说，IO多路复用机制需要使用事件分发器，来将读写事件源分发给读写事件的处理者。
**** Proactor
+ 基于异步 IO 的。
+ 事件处理者直接发起一个异步读写操作，而实际的工作是由操作系统来完成的。
+ 事件分发器得到这个请求，默默等待这个请求的完成，然后转发完成事件给相应的事件完成者或回调。
+ 你给我收十个字节，收好了你跟俺说一声
***** 操作步骤
1.等待事件到来（Proactor负责）。
2.得到读就绪事件，执行读数据（现在由Proactor负责）。
3.将读完成事件分发给用户处理器（Proactor负责）。
4.处理数据（用户处理器负责）。
**** Reactor
+ 基于同步 IO
+ 事件分发器等待某个事件或者某个可应用或可操作的状态的发生。
+ 转发给事先注册的回调，来做实际的读写操作。
+ 能收了你跟俺说一声
***** 操作步骤
1.等待事件到来（Reactor负责）。
2.将读就绪事件分发给用户定义的处理器（Reactor负责）。
3.读数据（用户处理器负责）。
4.处理数据（用户处理器负责）。

** JVM 垃圾收集
*** 对象死亡了吗
+ 引用计数法
+ 可达性分析
*** 垃圾回收算法 
+ 标记-清除算法
+ 复制算法
+ 标记-整理算法
+ 分代收集算法
*** HotSpot 算法优化
**** 枚举根节点
在可达性分析中，使用 OopMap 记录引用位置及类型。
**** 安全点
只在特定的点生成 OopMap -- 节省空间。
**** 安全区域
将安全点拓展到区域上 -- 防止无法响应 JVM 的中断请求。
*** 垃圾收集器
**** Serial 收集器
单线程，Client模式下的默认新生代收集器，简单高校。
**** ParNew 收集器
多线程，在单 CPU 下效果不好，在多个 CPU 情况下效果好。
**** Parallel Scavenge 收集器
+ 目的：达到一个可控制的吞吐量。
+ GC 停顿时间缩短是以牺牲吞吐量和新生代空间来换取的。
+ GC 自适应调整策略：通过检测来调整。
**** Serial Old 收集器
**** Parallel Old 收集器
Parallel Scavenge 的老年代版本。
**** CMS 收集器
+ 目的：获取最短回收停顿时间为目标。
+ 优点：并发收集，低停顿。
+ 缺点：
  + 对 CPU 资源敏感
  + 无法处理浮动垃圾
  + 大量空间碎片(标记-清楚）
**** G1 收集器
+ 新生代老年代通吃。
+ 特点：
  + 并行与并发
  + 分代收集
  + 空间整合
  + 可预测的停顿
+ G1 跟踪各个 Region 里面的垃圾收集堆积的价值大小。
+ 在 G1 收集器中使用 Remembered Set 来避免全堆扫描。
+ 在刷选阶段，根据用户所期望的 GC 停顿时间来制定回收计划。
+ 如果你的应用追求低停顿，那就可以选择 G1。

*** 内存分配与回收策略
不管是在新生代还是老年代，其内存不够时，发起Minor GC/Full GC。
**** 新生代
一般分为 Eden 和 Survivor（两个，轮换使用），8：1
**** 老年代
+ 大对象直接进入老年代
+ 长期存活的进入老年代
+ 动态对象年龄
** JVM 数据区域
+ 虚拟机栈
+ 本地方法栈：Native方法服务
+ 方法区：存储已被虚拟机加载的类信息、静态变量、即时编译器编译后的代码等数据。
+ 堆：存放对象实例。
** hashCode 与 equals 方法
*** equals 的作用
+ 用来判断两个对象是否相等
+ 在 JDK 中，通过判断两个对象的地址是否相等来区分它们是否相等
+ 可以依据需要对方法进行覆盖（如果没有覆盖，其作用和 == 相同）
*** hashCode 的作用
+ hashCode 的作用是获取哈希码，也称为散列码；它实际返回一个 int 整数。
*** equals 和 hashCode 之间的关系
**** 不会创建类对应的散列表
+ 不会在 HashSet HashTable HashMap 等本质上是散列表的数据结构中用到该类。 
+ 此时 hashCode 和 equals 无关。
**** 会创建类对应的散列表
+ 如果 equals 判断两个对象相等，则 hashCode 一定相等。
+ 如果两个对象的 hashCode 相等，其 equals 不一定判断相等。
+ 如果覆盖了 equals 方法，也需要覆盖对应的 hashCode 方法，否则散列表中将存在重复值。
** wait 和 sleep 的区别
+ sleep 是 Thread 类的方法，wait 是 Object 类中定义的方法。
+ sleep 不会导致锁行为的改变。而 wait 是会释放锁的。（可认为锁的方法都在 Object 类中）
+ 调用 wait 之后，需要别的线程调用 notify/notifyAll 才能重新获得 CPU 执行时间。
** Java类启动
+ 父类静态字段和静态代码段
+ 子类静态字段和静态代码段
+ 父类成员字段和代码块
+ 父类构造器
+ 子类成员字段和代码块
+ 子类构造器
** hashmap 和 hashtable
1.  关于HashMap的一些说法：
+ HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。
+ HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子。
+ HashMap实现不同步，线程不安全。  HashTable线程安全
+ HashMap中的key-value都是存储在Entry中的。
+ HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性
+ 解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。
注： 链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位；
   用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。
  拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。

2.  Hashtable和HashMap的区别：
+ 继承不同。 public class Hashtable extends Dictionary implements Map; public class HashMap extends  AbstractMap implements Map
+ Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。
+ Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断。
+ 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。
+ 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。
+ Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。

注：  HashSet子类依靠hashCode()和equal()方法来区分重复元素。
     HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。
** Java多线程实现的方式
*** 继承Thread类
+ Thread类本质上是实现了 Runnable 接口的一个实例。
+ 使用Thread类的start()实例方法启动新线程。
*** 实现 Runnable 接口
*** 实现 Callable 接口通过 FutureTask 包装器来创建 Thread 线程
*** 使用 Executor 框架进行线程的创建及管理
** 同步工具类
*** 闭锁
+ CountDownLatch
+ 计数器
+ 可以延迟线程的进度直到到达终止状态
*** FutureTask
+ Callable
+ 三个状态：等待运行、正在运行和运行完成
+ Future.get 的行为取决于任务的状态
+ 异步任务
*** 信号量
+ acquire, release
+ 用来控制同时访问某个特定资源的操作数量
*** 栅栏
+ 所有线程必须同时到达栅栏位置，才能继续执行。
+ 闭锁用于等待事件，而栅栏用于等待其他线程。
** 线程池
** 高级多线程控制类
*** ThreadLocal 类
+ 保存线程的独立变量
+ 常用于用户登陆控制，如记录session信息
+ 实现：每个线程都持有一个 ThreadLocalMap 类型的变量
*** 原子类
*** Lock 类
+ lock 更加灵活
+ 可提供多种形式的锁方案：
  + lock 阻塞式
  + trylock 无阻塞式
  + lockInterruptily 可打断式
+ ReentrantLock 可重入锁使得持有锁的线程可以继续持有
+ ReentrantReadWriteLock 可重入读写锁，适应于读远大于写的场合
*** 容器类
+ BlockingQueue
+ ConcurrentHashMap
*** 管理类
+ 线程池 ThreadPoolExecutor
* Python
** Python 和多线程
Python中有一个被称为Global Interpreter Lock（GIL）的东西，它会确保任何时候你的多个线程中，只有一个被执行。

Python并不支持真正意义上的多线程。Python中提供了多线程包，但是如果你想通过多线程提高代码的速度，使用多线程包并不是个好主意。
*** GIL
+ GIL 的出现是为了解决多线程之间数据一致性和状态同步的问题。
+ 适合于 IO 密集型的问题
+ 可以通过多进程，核心部分用其他语言实现，改用其他解释器来实现
+ 多核多线程下，由于会产生线程颠簸效应（其它CPU上唤醒的线程又重新进入待调度状态）
** 静态方法和类方法的区别
*** 相同点
都可以被类或成员所访问
*** 不同点
+ 静态方法无法访问类变量和实例变量
+ 类方法可以访问类变量，但无法访问实例变量
+ 静态方法有点像函数库
+ 类方法有点像Java中的静态方法，可用做对于参数的重载
** 迭代器和生成器
*** 迭代器
**** 迭代器协议
+ 迭代器协议：对象需要提供__next__方法和__iter__(返回自己）方法，它要么返回迭代的下一项，要么就引起一个 StopIteration 异常，以终止迭代。
+ 可迭代对象：实现了迭代器协议的对象。
+ 协议是一种约定，可迭代对象实现迭代器协议，Python 的内置工具（如for循环，sum,min,max函数等）使用迭代器协议访问对象。
*** 生成器
Python 使用生成器对延迟操作提供了支持。

Python 有两种不同的方式提供生成器：
+ 生成器函数：yield（挂起）
+ 生成器表达式：类似于列表推导（使用圆括号）

生成器的特点：
+ 语法上和函数类似
+ 自动实现迭代器协议
+ 状态挂起（yield挂起该生成器函数的状态，保留足够的信息，以便继续执行）
+ 只能遍历一次
* 计算机系统
** 并发与并行
+ 并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。
+ 并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。
** 进程，线程与协程
*** 进程与线程区别
+ 进程是资源分配的基本单位，线程是 CPU 调度/程序执行的最小单位。
+ 进程有独立的地址空间，需要维护页表等和内存缓存打交道的数据结构。
  + 进程共享状态信息比较困难，需要使用显示的 IPC 机制。
  + 线程之间的通信比较方便，使用(全局变量，静态变量等方式)。
+ 线程比进程的操作要快，花费要小。
+ 在 Linux 下本质都是 Task，需要共享的都可以选择，这两个概念上的差别被弱化了。
+ 同步与互斥的方法：临界区，事件，互斥量，信号量。
+ 多线程的好处：并发，更好的编程模型。
*** 协程
+ 非抢占式调度
+ 一般由语言层面提供
+ 用户态调度管理，开销小，切换速度快
+ 在协程中控制共享资源不加锁，只需要判断状态就好了
+ 可采用多进程+协程的方式利用多核CPU
**** goroutine
+ goroutine是 GO 语言中的轻量级实现，由Go运行时(runtime)管理。
+ 其是 GO 语言中独有的一种并发方式
+ 在一个函数前加上go关键字，这次调用就会在一个新的goroutine中并发执行。
+ 当被调用的函数返回时，这个goroutine也自动结束。
+ 在工程中最常使用共享内存和消息这两种并发通信机制。
+ M:N,M个用户线程在N个内核上运行
***** channel
消息机制认为每个并发单元是自包含的、独立的个体，并且都有自己的变量，
但在不同的并发单元间这些变量不共享。
每个并发单元的输入输出只有一种，那就是消息。
***** select
和case结合，代码优雅
***** Go runtime 的调度器
+ M:代表真正的内核OS线程，创建或从线程池里面取出的。
+ G:代表一个goroutine，它有自己的栈，pc和其他信息，用于调度。
+ P:代表调度的上下文，可以看作一个局部的调度器，使go代码在一个线程上跑。

每个M都有一个context(P)，每个P也都有一个正在运行的goroutine。
P的数量可以通过GOMAXPROCS()来设置，其代表了真正的并发度，即有多少个goroutine可以同时运行。

除了正在运行的G之外，P还维持了一个局部的队列(runqueue)，其到达一个调度点时从runqueue中取出一个G执行。

当一个线程阻塞时，即一个M阻塞，此时P可以转投另一个OS线程。
而M被唤醒后，会尝试去的一个P来运行goroutine。
如果失败，就将goroutine放在global runqueue中。

当一个P的局部runqueue和global runqueue 均执行完后，其会从其他的runqueue中获取。
** 线程安全
一个函数是线程安全的，当且仅当其被多个并发线程反复的调用时，一直会产生正确的结果。
*** 四类线程不安全函数
+ 不保护共享变量的函数
+ 保持跨越多个调用的状态的函数
+ 返回指向静态变量的指针的函数
+ 调用线程不安全函数的函数
*** 可重入
当他们被多个线程调用时，不会引用任何共享数据。
** 进程间通信
+ 管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道还允许无亲缘关系进程间的通信；
+ 信号（Signal）：用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；
+ 报文（Message）队列（消息队列）：消息队列是消息的链接表。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
+ 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
+ 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
+ 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。
** 静态库和动态库
1 静态链接库的优点 
+ 代码装载速度快，执行速度略比动态链接库快； 
+ 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 

2 动态链接库的优点 
+ 更加节省内存并减少页面交换；
+ DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；
+ 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；
+ 适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。

3 不足之处
 + 使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；
 + 使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。
   而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。
   当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。

* 计算机网络
** 网络 IO 模型
网络应用需要处理的无非就是两大类问题，网络I/O，数据计算。相对于后者，网络I/O的延迟，给应用带来的性能瓶颈大于后者

网络I/O的本质是socket的读取，socket在linux系统被抽象为流，I/O可以理解为对流的操作。这个操作又分为两个阶段：
+ 等待流数据准备（wating for the data to be ready）。
+ 从内核向进程复制数据（copying the data from the kernel to the process）。

对于socket流而已，
+ 第一步通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。
+ 第二步把数据从内核缓冲区复制到应用进程缓冲区。

*** 同步与异步的区别
+ 同步I/O操作：导致请求进程阻塞，直到I/O操作完成；异步I/O操作：不导致请求进程阻塞。（关键是第二步）
+ 阻塞，非阻塞：进程/线程要访问的数据是否就绪，进程/线程是否需要等待；
+ 同步，异步：访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。

*** 同步模型（synchronous I/O）
**** 阻塞I/O（bloking I/O）
+ 进程发起 recvform 系统调用，然后进程就被阻塞了，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据。
+ 在等待数据到处理数据的两个阶段，整个进程都被阻塞。
+ 阻塞IO的特点就是在IO执行的两个阶段都被block了
**** 非阻塞I/O（non-blocking I/O）
+ 也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error
+ 轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。
+ 拷贝数据整个过程，进程仍然是属于阻塞的状态
+ 非阻塞 IO的特点是用户进程需要不断的主动询问kernel数据是否准备好。
**** 多路复用I/O（multiplexing I/O）
多路复用的特点是通过一种机制一个进程能同时等待多个IO文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。
对于监视的方式，又可以分为 select， poll， epoll三种方式。

I/O多路复用的最大优势是系统开销小

第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。
第二个阶段都是阻塞的
***** select
内核级别的调用，能等待多个socket，并能同时实现对多个 IO 端口的监听。

当其中任何一个 socket 准备好了，就能返回进行可读，然后进程进行 recvform 系统调用，
将数据由内核拷贝到用户进程，当然这个过程是阻塞的。
***** poll
poll的实现和select非常相似，只是描述fd集合的方式不同，
***** epoll
+ epoll既然是对select和poll的改进
+ 而epoll提供了三个函数:
  + epoll_create是创建一个epoll句柄；
  + epoll_ctl是注册要监听的事件类型；
  + epoll_wait则是等待事件的产生。
**** 信号驱动式I/O（signal-driven I/O）
首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据
*** 异步I/O（asynchronous I/O）
相对于同步IO，异步IO不是顺序执行。
用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。
等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。
IO两个阶段，进程都是非阻塞的。

信号驱动I/O是由内核通知我们如何启动一个I/O操作，而异步I/O模型是由内核通知我们I/O操作何时完成。
** https
https 除了 TCP 的三个包之外，还需要 ssl 握手的9个包(非对称 and 签名，对称)

安全，但会导致建立连接的速度变慢，而且增加服务器资源的消耗。
** TCP 三次握手
*** 原因
 网络存在延迟，建立连接的数据报发到服务端时可能间隔时间过长，
 此时客户端已无建立连接的请求。
*** 具体过程
+ client -> server: SYN=1,seq=client_isn
+ server -> client: SYN=1,seq=server_isn,ack=client_isn+1
+ client -> server: SYN=0,seq=client_isn+1,ack=server_isn+1

(ack确认号，数字表示期望接受的下一个序列)
** TCP 四次挥手
*** 具体过程
+ client shutdown
+ client -> server: FIN
+ server -> client: ACK
+ client 依据ACK补发数据包，当ACK为FIN的时，进入FIN_WAIT2状态。
+ server 在发送FIN的ACK之后进入 CLOSE_WAIT 状态，结合app需求继续发送数据包。
+ server shutdown
+ server -> client: FIN，并进入 LAST_ACK 状态。
+ client -> server: ACK
+ server 收到的ACK不对，则补发之前的包
+ 当 client 回复 FIN 的 ACK 后，进入 TIME_WAIT 状态。
*** CLOSE_WAIT
在CLOSE_WAIT状态下，被动方还有数据需要传送。（被动方）

太多CLOSE_WAIT暗示了，被动方的应用程序没有合适地关闭socket。
*** TIME_WAIT
**** 有效的实现TCP全双工连接的终止
等待被关闭方应答ACK的确认。
如果主动关闭方最后的 ACK 丢失，那么最后关闭方将重发 FIN 。
**** 允许老的重复包在网络中消逝
防止新建立的连接收到旧的包，从而引起混乱。
**** time_wait状态在socket下需要等待两倍的MSL
MSL是一个数据在网络中单向发出到确认丢失的时间，
一个数据报可能在发送途中丢失，也可能在其响应过程中成为残余数据报。

总时间有两部分组成：ACK到达server时失效的情况（1msl)，加上重发FIN的时间(1msl)。
** TCP 重传
*** 目的
报文重传是 TCP 最基本的错误恢复功能，它的目的是防止报文丢失。
*** 重传时间的设置
+ 重传时间过短：在网络因为拥塞引起丢包时，频繁的重传会进一步加剧网络拥塞。
+ 重传时间过长：接收方长时间无法完成数据接收，引起长时间占用连接链路，消耗资源。
*** 重传计数器
重传计数器的主要功能是维护重传超时值(RTO)。
当报文使用 TCP 传输时，启动重传计时器，
除非收到 ACK 或者重传值达到上限，
当超时时，RTO 翻倍，并启动重传。
*** 超时重传
*** 快速重传
接收方发现有数据包丢失时，就会发送重复 ACK 报文来告诉发送端重传丢失的报文。
** TCP 流量控制
+ 管理两端的流量，以免会产生发送过快导致溢出，或处理过快而浪费时间的状态。
+ 主要采用滑动窗口进行流量控制。
+ 滑动窗口表示的是接收方能接收数据的大小。(缓冲区的剩余大小）
+ 对于TCP会话的发送方，“已经发送但还未收到对端ACK的”和“未发送但对端允许发送的”这两部分数据称之为发送窗口。
+ 比特滑动窗口协议，回退n协议，选择重传协议
** TCP 拥塞控制
*** 目的
避免过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。
*** 算法
**** 慢启动
拥塞窗口是慢速启动的，但是按指数规则增长。直到到达一个阈值。
**** 拥塞避免:加法增加
为了在慢速发生之前避免拥塞，必须降低指数增长的速度。
其通过加法增加拥塞窗口。
**** 拥塞发生：乘性减少
重传的发生存在两种情况:

1)如果 RTO 超时，那么存在非常严重的拥塞的可能性；包可能已在网络中丢失。
在这种情况下，TCP 做出强烈的反应：
+ 设置阈值为 cwnd 的一半
+ 重新设置 cwnd 为1
+ 启动慢速启动阶段

2)如果收到3个相同的 ACK，那么存在着轻度拥塞的情况。此时做出快速重传的同时，执行下面的步骤
+ 设置阈值为 cwnd 的一半
+ 设置 cwnd 为阈值 + 3MSS
+ 启动快速恢复阶段
**** 快速恢复
当收到3个重复的 ACK 之后，TCP 之后进入快速恢复阶段。

快速恢复状态是一种介于慢启动和拥塞避免之间的状态。
在这个阶段可能发生三种事件：
+ 重复 ACK 继续到达，那么 TCP 保持这种状态，但是 cwnd 呈指数增长。
+ 如果发生超时， TCP 假设网络中有真实的拥塞，并进入慢启动状态。
+ 如果一个新的 ACK 到达，TCP 进入拥塞避免状态。但是 cwnd 大小减少到阈值。
** 如何让 UDP 实现可靠传输
+ UDP 不属于连接型协议，具有资源消耗小，处理速度快的优点。
+ 在应用层实现确认机制、重传机制、窗口确认机制。
+ 如果你不利用linux协议栈以及上层socket机制，自己通过抓包和发包的方式去实现可靠性传输，那么必须实现如下功能：
  + 发送：包的分片、包确认、包的重发
  + 接收：包的调序、包的序号确认
** HTTP 长连接短连接
*** 短连接
 连接->传输数据->关闭连接 
*** 长连接
连接->传输数据->保持连接 -> 传输数据-> ...........->直到一方关闭连接，多是客户端关闭连接。 

长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。
*** HTTP的特点
HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。
也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。
HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。

+ HTTP1.1，增加了持久连接支持(貌似最新的HTTP1.1 可以显示的指定 keep-alive),但还是无状态的，或者说是不可以信任的。
+ 从 HTTP 1.1 开始，默认支持长连接，其 keep-alive不会永久保持连接，其有一个保持时间。
*** 什么时候用长连接，短连接
+ 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。
+ 实现长连接要客户端和服务端都支持长连接。
+ 并发量大，但每个用户无需频繁操作情况下需用短连好。比如 web 网站的 http 服务。
*** 长短连接的比较
+ 长连接可以省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间。
+ 不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测 TCP 连接的存活。
+ 短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。
+ 但如果客户请求频繁，将在 TCP 的建立和关闭操作上浪费时间和带宽
** Cookie 和 Session
*** Session
+ HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，使用 Session 机制来识别具体的用户。
+ 保存在服务端，有一个唯一的标识。
+ Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中
+ session 的运行依赖 session id，其是存在 cookie 中的，如果浏览器禁用了 cookie，需要通过其他方法实现，比如在 url 中传递 session_id。
*** Cookie
+ 实现 Session 跟踪特定用户的方法。
+ Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。
** HTTP 请求响应报文格式
*** HTTP 请求报文
一个 HTTP 请求报文由：请求行，请求头部，空行和请求数据四个部分组成。
**** 请求行
+ 请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔
+ 例如：GET /index.html HTTP/1.1
+ HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT
***** GET
+ 最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。
+ GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。
***** POST
+ POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中
***** HEAD
+ HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。
+ 当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。
***** GET 和 POST 的区别
+ GET提交，请求的数据会附在URL之后，以?分割URL和传输数据，多个参数用&连接; POST提交：把提交的数据放置在是HTTP包的包体。
+ HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。但是GET:特定浏览器和服务器对URL长度有限制。
+ POST的安全性要比GET的安全性高;通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存， (2)其他人查看浏览器的历史纪录
**** 请求头部
+ 请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。
+ 请求头部通知服务器有关于客户端请求的信息
+ 典型的请求头部有：User-Agent，Accept，Host。
**** 空行
最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。
**** 请求数据
请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是Content-Type和Content-Length。
*** HTTP 响应报文
HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行，响应正文。
**** 状态行
HTTP-Version Status-Code Reason-Phrase CRLF
+ HTTP-Version表示服务器HTTP协议的版本；
+ Status-Code表示服务器发回的响应状态代码；
+ Reason-Phrase表示状态代码的文本描述
**** 消息报头
+ key:value 形式
+ 表示响应的相关信息
** HTTP 常见状态码
*** 1开头
+ 1xx(临时响应)表示临时响应并需要请求者继续执行操作的状态代码
*** 2开头
+ 2xx (成功)表示成功处理了请求的状态代码
+ 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
+ 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。
+ 206 (部分内容) 服务器成功处理了部分 GET 请求(客户端进行了范围请求)。 
*** 3开头
+ 3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
+ 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。
+ 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
+ 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。(包含的其他文件）
+ 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
+ 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
*** 4开头
+ 4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理。
+ 400 (错误请求) 服务器不理解请求的语法。
+ 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
+ 403 (禁止) 服务器拒绝请求。
+ 404 (未找到) 服务器找不到请求的网页。
*** 5开头
+ 5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。
+ 500 (服务器内部错误) 服务器遇到错误，无法完成请求。
+ 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。
** 子网掩码
+ 未做子网划分的 IP 地址：网络号＋主机号
+ 做子网划分后的 IP 地址：网络号＋子网号＋子网主机号 
+ 192.168.1.x 子网掩码 255.255.255.0
+ 192.168.1.x/24（*nix表示法）意思一致。
** 当你在浏览器中输入一个 url 后发生了什么
*** 解析URL
浏览器会首先判断地址栏中输入的是 URL 还是搜索的关键字，
如果输入的协议或主机名不合法时，浏览器就会把文字传递给搜索引擎。
*** 检查 HSTS 列表
+ 浏览器检查自带的“预加载HSTS(HTTP严格传输安全)”列表，这个列表中包含了那些请求浏览器只使用 HTTPS 进行连接的网站。
+ 如果网站在这个列表里，浏览器就会使用 HTTPS 而不是 HTTP 协议。
+ 注意，如果一个网站不在 HSTS 列表里，也可以要求浏览器使用 HSTS 政策进行访问，这个发生在第一个 HTTP 请求之后，不过会遭到降级攻击。
*** 转换非ASCII的Unicode字符
+ 浏览器检查输入是否含有不是 a-z, A-Z,0-9,-或者.的字符。
+ 如果含有非ASCII字符，则采用Punycode编码。
*** DNS 查询
+ 浏览器检查域名是否在缓存中
+ 如果缓存中没有，就去调用 gethostbyname 库函数。
+ 如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它就会向DNS服务器发送一条DNS查询请求。DNS路由器是由网络通信栈提供的，通常是本地路由器或者ISP的缓存DNS服务器。
+ 如果 DNS 服务器和我们的主机在同一个子网内，系统会发送 DNS 查询到 DNS 服务器。
+ 如果 DNS 服务器和我们的主机在不同的子网，系统会发送 DNS 查询到默认网关。
*** ARP
要从链路层在子网内发送数据包，除了需要知道目标IP地址之外，还需要知道目标的MAC地址。
+ 首先查询ARP缓存，如果命中，则返回结果
+ 如果没有
  + 查看路由表，看看目标IP地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。
  + 查询连接的网络接口的MAC地址
  + 发送ARP请求

根据连接主机和路由器的硬件类型的不同，可以分为以下几种情况：
+ 直连：如果我们和路由器是直接连接的，路由器会返回一个ARP Reply。
+ 集线器：如果我们连接一个集线器，集线器会把ARP请求向所有其它端口广播。
+ 交换机：交换机会检查本地 MAC表，看看哪个端口有我们要找的那个MAC地址，如果都没有，则向其他端口广播这个ARP请求。

现在我们有了DNS服务器或者默认网关的IP地址和MAC地址，我们可以继续DNS请求了：
+ 使用53端口向DNS服务器发送UDP请求包，如果包太大，则使用TCP
+ 如果本地ISP 或DNS服务器没有找到结果，它会发送一个递归查询请求给高层DNS服务器。
+ 对于网关路由器，其通过IP层的路由算法将封包转发到下一个路由。
*** 使用套接字
当浏览器得到了目标服务器的IP地址，以及URL中给出来的端口号(http是80，https是443)，调用系统socket，创建一个TCP套接字。
+ 在传输层，目标端口会被加入头部，源端口会在系统内核中动态选取。
+ 在网络层，添加了IP头部，其中包含了目标服务器的IP地址以及本机的IP地址。
+ 在链路层，添加了frame头部，包含了本地和目标MAC。
*** 建立连接
**** TCP三次握手
**** TLS握手
*** HTTP
*** 浏览器显示
* 数据库
** 数据库范式
*** 范式
一张数据表的表结构所符合的某种设计标准的级别。
*** 第一范式(1NF)
符合1NF的关系中的每个属性都不可再分

1NF是所有关系型数据库的最基本的要求
*** 第二范式(2NF)
在1NF的基础上消除了非主属性对码的部分函数依赖
**** 函数依赖
若在一张表中，在属性(或属性组)X的值确定的情况下，必定能确定属性Y的值，记X->Y。
***** 完全函数依赖
对于X的任何一个真子集X'，不存在X'->Y
***** 部分函数依赖
非完全函数依赖
***** 传递函数依赖
若Y->Z，且X->Y，那么我们称Z传递函数依赖于X。
**** 码
对于属性(或属性组)K，若除K之外的所有属性都完全依赖于K，那么我们称K为候选码。
**** 主属性
包含在任意一个码中的属性
*** 第三范式(3NF)
3NF在2NF的基础上，消除了非主属性对于码的传递函数的依赖。
*** BCNF 范式
在3NF的基础上消除了主属性对于码的部分与传递函数的依赖。

(主属性/码 过多)
** 数据库指令
schema 是对一个数据库的结构性描述。
其在一个关系型数据库中，定义了表，每个表的字段，还有表和字段之间的关系。
*** DDL(Data Definition Language)
数据定义语言：被用来定义数据框架和 schema，立即提交
+ CREATE
+ ALTER
+ DROP-删除整个表
+ TRUNCATE-清空表中数据
+ COMMENT
+ RENAME
*** DML(Data Manipulation Language)
数据操作语言：用来管理 schema 中对象的语言
+ SELECT
+ INSERT
+ UPDATE
+ DELETE-删除一个表中的数据，一般用于删除特定行
+ MERGE-insert or update
+ CALL-调用一个PL/SQL或者Java子程序
+ EXPLAIN PLAN
+ LOCK TABLE
*** DCL(Data Control Language)
+ GRANT-授予用户访问数据库的权限
+ REVOKE-收回权限
*** TCL(Transaction Control Language)
事务控制语言用来管理数据操作语言带来的变动。
它允许语句以逻辑事务的形式进行组合。
+ COMMIT
+ SAVEPOINT：使用保留点
+ ROLLBACK
+ SET TRANSACTION:改变事务选项（隔离等级，回退段）
** 关系型与非关系型数据库
** 什么是存储过程
*** 存储过程与函数
存储过程是一些预编译的SQL语句，涉及特定表及其他任务，用户可以执行存储过程。

函数是数据库已定义的方法，它接收参数并且返回某种类型的值，并且不涉及特定用户表。
*** 存储过程的优点
+ 存储过程是一个预编译的代码块，执行效率高。
+ 一个存储过程替代大量的SQL语句，可以降低网络通信量。
+ 可以在一定程度上确保数据安全。
** 索引及其优缺点
索引是对数据库表中一或多个列的值进行排序的结构，是帮助 MySQL 高效获取数据的结构。
*** 索引类型
+ 普通索引
+ 唯一索引
+ 主键索引
+ 全文索引
*** 索引的优缺点
+ 索引加快数据库的检索速度
+ 索引降低了插入、删除、修改等维护任务的速度
+ 唯一索引可以确保每一行数据的唯一性
+ 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
+ 索引需要占物理和数据空间
*** 使用索引查询一定能提高查询的性能吗？
通常，通过索引查询数据比全表扫描要快，但是我们也必须注意到它的代价。

索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，
索引本身也会被修改。这意味着条记录的 INSERT, DELETE, UPDATE将为此多付出4,5次的磁盘 I/O。
因为索引需要额外的存储空间和处理，那些不必要的索引反而会似的查询反应时间变慢。
*** 索引范围查询
+ 基于一个范围的检索，一般查询返回结果集小于表中记录数的30%
+ 基于非唯一性索引的检索
*** 聚集索引和非聚集索引
聚集索引的顺序是数据的物理存储顺序，而对非聚集索引的顺序与数据物理排列顺序无关。
因此，一个表最多只能有一个聚集索引。

聚集索引对于那些经常要搜索范围值的列特别有效。
使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。
对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集(物理排序)。

在非聚集索引中，数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。
索引中的项目按索引键值的顺序存储，而表中的信息按另一种顺序存储。
** 事务
事务是并发控制的基本单位。
它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。
事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。
*** ACID
**** Atomic 原子性
事务中包含的操作被看作是一个逻辑单位，其要么全部成功，要么全部失败。
**** Consistency 一致性
只有合法的数据可以被写入数据库，否则事务回滚到最初状态。
**** Isolation 隔离性
事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。
同时，并行事务的修改必须能与其他并行事务的修改相互独立。
**** Durability 持久性
事务结束后，事务处理的结果必须能够得到固化。
** 乐观锁和悲观锁
乐观并发控制和悲观并发控制是并发控制主要采用的技术手段。
+ 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。
+ 乐观锁：假定不会发生并发冲突，只在提交操作时检查是否违反数据完整性。
** 游标
在检索出来的行中，前进或后退一行或多行。

通过判断全局变量@@FETCH_STATUS可以判断其是否到了最后。
通常此变量不等于0表示出错或到了最后。
** 触发器
+ 触发器是特殊的存储过程，它在特殊的数据库活动发生时自动执行。
+ 约束的处理比触发器更快。
+ 事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。
+ 语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。
** SQL注入式攻击
*** 定义
 攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串中，欺骗服务器执行恶意的SQL命令。
 在某些表单中，用户的输入内容直接用来构造动态SQL命令，或作为存储过程的输入参数，这类表单特别容易受到SQL注入攻击。

*** 防范措施
+ 替换单引号
+ 删除用户输入中的所有连字符
+ 限制执行查询的数据库账户权限
+ 用存储过程来执行查询
+ 检查用户输入的合法性
+ 将用户信息加密保存
+ 检查提取数据的查询所返回的记录数量
** drop、delete和truncate
+ delete和truncate只删除表的数据不删除表的结构
+ 速度：drop>truncate>delete
+ delete是dml，而truncate和drop是ddl。
+ 不再需要一张表时，使用drop
+ 想删除部分行时用delete
+ 保留表而删除所有数据时用truncate
** 超键，候选键，主键，外键
+ 超键：在关系中能唯一识别元组的属性集。
+ 候选键：最小超键，没有冗余元素的超键。
+ 主键：一个表只能有一个主键，且不能为空值。
+ 外键：在一个表中存在的另一个表的主键。
** 视图
视图是一种虚拟的表，其包含的是使用时动态数据的检索。
视图通常是有一个表或者多个表的行或列的子集。
可以对视图进行增，改，查等操作。(不同的DBMS，要求不同)
* 算法与数据结构
** 红黑树
*** 红黑性质
+ 每个结点非红即黑
+ 根结点为黑
+ 每个叶子(NIL)为黑
+ 如果一个结点为红，它的两个子结点均为黑
+ 对于每个结点，所有从该结点到其后代叶子的简单路径均含有相同数量的黑色结点
*** 红黑树的特点
+ 一个含有 n 个内部结点的红黑树，其高度最多为2lg(n+1)
*** 旋转
* 设计模式
** 创建型模式
*** 抽象工厂
提供一个创建一系列相关或相互依赖对象的接口，无需指定它们具体的类。

抽象工厂的优缺点：
+ 分离了具体的类
+ 使得易于交换产品系列
+ 有利于产品的一致性
+ 难以支持新种类的产品
*** 生成器
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

其由两部分组成：
+ Builder：为创建一个Product对象的各个部件指定抽象接口。
+ Director：构造一个使用Builder接口的对象。

Build模式的效果：
+ 它使得你可以改变一个产品的内部表示
+ 它将构造代码和表示代码分开
+ 它使你可对构造过程进行更精细的控制
*** 工厂方法
*** 原型
*** 单件
**** 单价模式的几种写法
***** 懒汉式
#+BEGIN_SRC java
  public class Singleton{
      private Singleton static instance;
      private Singleton(){}
      public static synchronized Singleton getInstance() {
          if (instance == null) {
              instance = new Singleton();
          }
          return instance;
      }
  }
#+END_SRC
***** 双重检验锁
#+BEGIN_SRC java
  public class Singleton {
      private volatile static Singleton instance; //声明成 volatile
      private Singleton (){}
      public static Singleton getSingleton() {
          if (instance == null) {                         
              synchronized (Singleton.class) {
                  if (instance == null) {       
                      instance = new Singleton();
                  }
              }
          }
          return instance;
      }
  }
#+END_SRC

这里 instance 必须声明为 volatile 来形成内存屏障，阻止指令重排序。
对于语句 instance = new Singleton()。JVM 大概做三件事：
#+BEGIN_EXAMPLE
  1.给instance 分配内存
  2.调用 Singleton 的构造函数来初始化成员变量
  3.将 instance 对象指向分配的内存空间
#+END_EXAMPLE

经过 JVM 的即时编译器的指令重排序优化之后，最终的执行顺序可能为1-3-2。
此时当3执行完而2未执行时，被另一线程抢占，这时 instance 已经是非 null 了，产生错误。
***** 饿汉式
#+BEGIN_SRC java
  public class Singleton() {
      private static final instance = new Singleton();
      private Singleton() {}
      public static Singleton getInstance(){
          return instance;
      }
  }
#+END_SRC
***** 静态内部类
#+BEGIN_SRC java
  public class Singleton() {
      private Singleton(){}
      private static class SingletonHolder{
          private static final Singleton INSTANCE = new Singleton();
      }
      public static Singleton getInstance(){
          return SingletonHolder.INSTANCE;
      }
  }
#+END_SRC

***** 枚举 Enum
#+BEGIN_SRC java
  public enum Singleton{
      INSTANCE;
  }
#+END_SRC
** 结构型模式
*** 适配器模式
将一个类的接口转换为客户希望的另一个接口。
Adapter模式使得原本接口不兼容而不能一起工作的那些类可以一起工作了。

有时，为复用而设计的工具箱类不能被复用的原因仅仅是因为它的接口与专业应用领域的接口不匹配。
*** 桥接模式
将抽象部分与它们的实现部分分离，使它们都可以独立变化。

继承机制将抽象部分与它们的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。

把平台实现提取出抽象层，隔离封装。
*** 组合模式
将对象组合成树形结构以表示“部分-整体”的层次结构。
Composite 使得用户对单个对象和组合对象的使用具有一致性。

Composite 模式的关键是一个抽象类，它既可以代表图元，又可以代表图元的容器。
*** 装饰模式
动态地给一个对象增加一些额外的职责。
就增加功能来说，Decorator 模式相比生成子类更加灵活。
*** 外观模式
为子系统的一组借口提供一个一致的界面，Facade 模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

将一个系统划分为若干个子系统有利于降低系统的复杂性。
引入外观模式可以给子系统提供一个单一而简单的界面。
*** 享元模式
运用共享技术有效地支持大量细粒度的对象。(类似 constant pool)

有些应用程序得益于在整个设计过程中采用对象技术，但简单化的实现代价极大。

flyweight 共享对象：
+ 内部状态：存储于 flyweight 中，它包含独立于 flyweight 场景的信息，能够被共享。
+ 外部状态：取决于 flyweight 场景，并根据场景而变化，因此不能共享。(使用特殊的数据结构来进行表示)

适用场景：
+ 一个应用程序中使用了大量的对象
+ 完全由于使用大量的对象，造成很大的存储开销
+ 对象的大多数状态都变为外部状态
+ 如果删除对象的外部状态，那么可以用相对较少的共享对象来取代很多组对象
+ 应用程序不依赖于对象标识。
*** 代理模式
为其他对象提供一种代理以控制对这个对象的访问。

常见使用场景：
+ 远程代理：为了一个对象在不同的地址空间提供局部代理
+ 虚代理：根据需要创建开销大的对象
+ 保护代理：控制对原始对象的访问
+ 智能指引：取代了简单的指针，它在访问对象时执行一些附加操作。
** 行为型模式
* Linux 命令
** ldd 查看程序依赖库
作用：用来查看程式所需的共享库，常用来解决程式因缺少某个库文件而不能运行的一些问题。
** lsof 一切皆文件
lsof(list open files)是一个查看当前系统文件的工具。
在 linux 环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。
如传输控制协议(TCP)和用户数据报协议(UDP)套接字等，系统在后台都为该应用程序分配一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。
** ps 进程查看器
Process Status。用来列出系统中当前运行的那些进程。
ps 命令列出的是当前那些进程的快照，就是执行 ps 命令的那个时刻的那些进程，
如果想要动态的现实进程信息，就可以使用 top 命令。
** pstack 跟踪进程栈
此命令可显示每个进程的栈跟踪。
pstack 命令必须由相应进程的属主或 root 运行。
可以使用 pstack 来确定进程挂起的位置。
此命令唯一选项是要检查的进程的 PID。
** strace 跟踪进程中的系统调用
strace 常用来跟踪进程执行时的系统调用和所接收的信号。
其可以跟踪到一个进程产生的系统调用，包括参数，返回值，执行消耗的时间。
** ipcs 查询进程间的通信
ipcs 是 linux 下显示进程见通信设施状态的工具。可以显示消息队列，共享内存和信号量的信息。
** top linux 下的任务管理器
top 命令是 Linux 下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况。
** free 查询可用内存
** vmstat 监视内存使用情况
Virtual Memory Statistics。可实时动态监视操作系统的虚拟内存、进程、CPU活动。
** iostat 监视 I/O 子系统
I/O statistics。用来动态监视系统的磁盘操作活动。
** sar 找出系统瓶颈的利器
System Activity Reporter 系统活动情况报告。
sar 工具将对系统当前的状态进行取样，然后通过计算数据和对象来表达系统的当前运行状态。
其所需的负载很小。

从下面方面对系统的活动进行报告：
+ 文件的读写情况
+ 系统调用的使用情况
+ 串口
+ CPU效率
+ 内存使用状况
+ 进程活动
+ IPC有关活动
** readelf elf文件格式分析
这个工具和 objdump 命令提供的功能类似，但是它显示的信息更为具体，
并且它不依赖BFD库。

ELF(Executable and Linking Format)是一种对象文件的格式，
用于定义不同类型的对象文件都放了什么。
** objdump 二进制文件分析
objdump 工具用来显示二进制文件的信息。
** nm 目标文件格式分析
nm 命令显示关于指定 File 中符号的信息，文件可以是对象文件、可执行文件或对象文件库。
** size 查看程序内存映像大小
查看程序被映射到内存中的映像所占用的大小信息。
** wget 文件下载
Linux 系统中的 wget 是一个下载文件的工具，它用在命令行下。
其支持 HTTP,HTTPS和FTP协议，可以使用HTTP代理。

特点：
+ 稳定
+ 递归下载
+ 断点续传
** scp 跨机远程拷贝
secure copy。用于 Linux 下进行远程拷贝文件的命令。
** crontab 定时任务
时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。
这个命令适合周期性的日志分析或数据备份。
* 面试
** 应聘者提问
提与招聘职位或项目相关的问题。
